./ ADD NAME=DERCOM   0100-01324-01324-1743-00726-00726-00000-DERU-S
**********************************************************************
*
*                     +---------+
*     Module Name  -  | DERCOM  |
*                     +---------+
*                     CA-Dispatch -to- CA-XCOM Handshaking Interface
*
*     Function -
*            Command processor
*
*
*     Operating Environment -
*        Type              MVS System Program
*        Min. Auth.        Problem state
*        Dsp.unit mode     Task
*        AMODE             24-bit or 31-bit
*        XM                PASN=HASN=SASN
*        ASC mode          Primary
*        Interrupt status  Enabled for I/O and Ext. interrupts
*        Locks             No locks held
*        Control Parm      The SSOB and SSSO control blocks can
*                          reside in storage above 16 megabytes.
*        Recovery          Program should provide an ESTAE-type
*                          recovery environment. See MVS/ESA SP V5
*                          Auth Assembler Services Guide for more info
*                          an ESTAE-type recovery environment.
*
*
*     Syntax -
*
*
*     Operation -
*           Called by DERXDI via LOAD and BASR
*
*     Register Usage -
*          R0-R1   -->  System interface
*          R2-R7   -->  Work registers
*          R8      -->  DCB map (IHADCB) address
*          R9      -->  Module extension base address
*          R10     -->  WSA (working storage area) address
*          R11     -->  Main module base address
*          R12     -->  Main module base address
*          R13     -->  Conventional savearea
*          R14     -->  BAS or BASR return address
*          R15     -->  Return code
*
*     Author -
*          Name     :  Deru Sudibyo
*                      Technical Consultant
*                      Computer Associates
*                      Indonesia Office
*                      Wisma BNI-46 34th floor, BNI-46 City
*                      Jl. Jend. Sudirman, Kav 1, Jakarta Pusat
*          Copyright:  (C)1998 Deru Sudibyo
*
*     Disclaimer -
*         This module is developed as a personal support, and is
*         not a part of CA support matterials.  The purpose is as
*         a temporary solution or even just a sample.  Therefor,
*         further modifications and maintenance are client's
*         responsibilities.
*
*     Modification Log -
*     +--------+------------+--------+---------------------------+
*     | Date   | Engineer   | V.R.L. | Description               |
*     +--------+------------+--------+---------------------------+
*     |98/02/12| Deru S.    | 1.0.0. | First development         |
*     |        |            |        |                           |
*     |        |            |        |                           |
*     |        |            |        |                           |
*     |        |            |        |                           |
*     |        |            |        |                           |
*     |        |            |        |                           |
*     +--------+------------+--------+---------------------------+
*
*
         EJECT ,
DERCOM   @PROLOG ESA=390,                                              +
               AMODE=31,                                               +
               RMODE=ANY,                                              +
               RENT=YES,                                               +
               BREG=(R11,R12)
*
         USING DCBE,R7            Establish DCBE structure map
         USING IHADCB,R8          Establish DCB structure map
         USING DERWTX,R9          Establish Module extension logic map
         USING WSA,R10            Establish WSA structure map
*
*        LR    R10,R1             Enable WSA map
*        L     R9,WSMODWTX        Enable WTX map
*
         LOAD  EP=DERWSA
         LR    R10,R0             Establish WSA addressability
         LOAD  EP=DERWTX
         LR    R9,R0              Establish WTX addressability
         EJECT ,
* ================================================================= *
*                                                                   *
*   Possible Commands (Entered via MODIFY)                          *
*                                                                   *
*      CLASS=cccccccc         1 to 8 spool classes                  *
*      PCFORM=ffffffff        Form to used for PC                   *
*      DISP=<KEEP¦DELETE>     Disp. of spool after processed        *
*      XDISP=<KEEP¦DELETE>    Disp. of XCOM job's LCLDS01 file      *
*      TRACE=<ON¦OFF>         Trace message                         *
*      TABLE=nn               Load table XDITABxx                   *
*      XPARM=<XCOM job parameter>                                   *
*                                                                   *
* ================================================================= *
         SPACE ,
         @WTO  CODE=103
         LA    R2,WSCOMBUF            Access 1st parameter address
         CLC   =C'LIST ',2(R2)        Is it LIST request ?
         BE    SHOWPARM               Yes, show parameter
         CLC   =C'L ',2(R2)           Is it L request ?
         BE    SHOWPARM               Yes, same effect - show parameter
         NI    WSPFLAGS,X'FF'-WSPFFILE Turn indicator off
         CLC   =C'TABLE=',2(R2)       Is TABLE=mm specified ?
         BE    DESTTAB                No, skip NSI
         CLC   =C'FILE=',2(R2)        Is FILE=mm specified ?
         BNE   CHKPARM                No, skip NSI
PARM_FILE EQU  *
         MVC   WSPARMM(6),=CL6'XDISYS'      Set basic member name
         MVC   WSPARMM+6(2),7(R2)        Put suffix
         BAS   R14,OPEN_PARM          Yes, open parmlib
         OI    WSPFLAGS,WSPFFILE      Turn indicator on
         MVC   WSIOREC,WSIOBUF        Access 1st record of block
PARM_REC EQU   *
         L     R2,WSIOREC             Access a record of block
PARM_REC_CHECK EQU *
         C     R2,WSIOREC+4           Overlimit ?
         BH    PARMNEXT               Go out if so
         CLI   0(R2),C' '             Empty record ?
         BE    PARM_REC_NEXT          Seek next record if so
         CLI   0(R2),C'*'             Commented record ?
         BNE   PARM_REC_CONT          Begin to check record if not
PARM_REC_NEXT  EQU *
         LA    R2,80(,R2)
         B     PARM_REC_CHECK         Iterate
PARM_REC_CONT  EQU *
         LR    R3,R2                  Address of record
         LA    R7,72                  Max parm length is 72
PARM_REC_LOOP  EQU *
         CLI   0(R3),C' '             End of parm ?
         BE    PARM_REC_END           Yes, leave loop
         LA    R3,1(,R3)              Seek next byte
         BCT   R7,PARM_REC_LOOP       Iterate
PARM_REC_END   EQU *
         MVC   WSCARD+2(72),0(R2)       Bring parm record as well
         LA    R2,80(,R2)             Next record address
         ST    R2,WSIOREC             and save here
         LA    R2,WSCARD              Address of card
         LA    R3,72
         STH   R3,WSCARD
         LA    R2,WSCARD
         WTO   TEXT=(R2),MF=(E,LWTO)
         LA    R2,WSCARD+2            Address of parameter
         B     CHKPARM1               Skip NSI
DESTTAB  EQU   *
         MVC   WSTABLE(6),=C'XDITAB'
         MVC   WSTABLE+6(2),0(R2)
         OI    WSPFLAGS,WSPFTABL      Indicate table will be renew
         B     UPDATE_TABLE
CHKPARM  EQU   *
         LA    R2,WSCOMBUF            Access 1st parameter address
         XR    R7,R7                  Clear R7
         ICM   R7,B'0011',WSCOMBUF    Parameter length
         LA    R2,2(,R2)              Straight to parm area
CHKPARM1 EQU   *
         LA    R3,PARMKEYS            Point to parm table
         LA    R4,PARMKEYN            Number of entries
         XR    R5,R5                  Zap GR 5
PARMLOOP EQU   *
         IC    R5,3(R3)               Get keyword string length
         EX    R5,CHKKEYWD            Is it the right keyword ?
         BE    PARMOKEY               Yes, handle it
         LA    R3,PARMKEYW(R3)        Seek next entry
         BCT   R4,PARMLOOP            and iterate
         @MESSAGE ERROR,OPCODE=B,OBJECT=(R2),TYPE=PARM,                +
               RC=*,EXIT=PARMNEXT
         B     PARMNEXT               Get next parm
PARMKEYS DS    0H
   DC Y(CHKCLS-PARMKEYS),AL1(*-*,7,8,0),CL8'CLASSES='
   DC Y(CHKCLS-PARMKEYS),AL1(*-*,5,6,0),CL8'CLASS=  '
   DC Y(CHKRQC-PARMKEYS),AL1(*-*,7,8,0),CL8'RQCLASS='
   DC Y(CHKFRM-PARMKEYS),AL1(*-*,6,7,0),CL8'PCFORM= '
   DC Y(CHKTRC-PARMKEYS),AL1(*-*,5,6,0),CL8'TRACE=  '
   DC Y(CHKDSP-PARMKEYS),AL1(*-*,4,5,0),CL8'DISP=   '
   DC Y(CHKXDS-PARMKEYS),AL1(*-*,5,6,0),CL8'XDISP=  '
   DC Y(CHKHLD-PARMKEYS),AL1(*-*,4,5,0),CL8'HOLD=   '
   DC Y(CHKHDD-PARMKEYS),AL1(*-*,7,8,0),CL8'PCDRIVE='
   DC Y(CHKTAB-PARMKEYS),AL1(*-*,7,8,0),CL8'DESTTAB='
   DC Y(CHKTAB-PARMKEYS),AL1(*-*,5,6,0),CL8'TABLE=  '
   DC Y(CHKXCP-PARMKEYS),AL1(*-*,5,6,0),CL8'XPARM=  '
PARMKLEN EQU   *-PARMKEYS
PARMKEYW EQU   14
PARMKEYN EQU   PARMKLEN/PARMKEYW
         SPACE ,
CHKKEYWD CLC   6(*-*,R3),0(R2)             << Executed >>
GETPARM  MVC   0(*-*,R6),0(R2)             << Executed >>
         SPACE ,
PARMOKEY EQU   *
         LA    R2,1(R5,R2)            Jump over the keyword
         LR    R4,R7                  Copy parm length
         SR    R4,R5                  Reduced by kwd length
         LR    R7,R4                  Copy to GR 7
         BCTR  R4,0                   Reduced again by 1
         IC    R5,4(R3)               Get parm string length
         LH    R6,0(,R3)              Get relocation factor
         B     PARMKEYS(R6)           Relocate and go
*
*   +---------------------------------------------------+
*   ¦                                                   ¦
*   ¦   Check Harddisk PC Drive Letter                  ¦
*   ¦                                                   ¦
*   +---------------------------------------------------+
*
CHKHDD   EQU   *
         MVC   WSPCHDD,0(R2)          Get HDD letter
         B     PARMNEXT               Get next parm
*
*   +---------------------------------------------------+
*   ¦                                                   ¦
*   ¦   Check XPARM Parameter                           ¦
*   ¦     Get list of 1 to 38 byte job parameter in     ¦
*   ¦     the form of:                                  ¦
*   ¦                                                   ¦
*   ¦     XPARM=('ACBNAME=aaaaaaaa,TYPE=tttttttt')      ¦
*   ¦                                                   ¦
*   +---------------------------------------------------+
*
CHKXCP   EQU   *
         MVI   WSXCJPRM,C' '
         MVC   WSXCJPRM+1(L'WSXCJPRM-1),WSXCJPRM
         LA    R6,WSXCJPRM            Address of target
         BAS   R14,COPYPARM           Perform copy parameter
         B     PARMNEXT               Get next parm
*
*
*   +---------------------------------------------------+
*   ¦                                                   ¦
*   ¦   Check TABLE or DESTTAB Parameter                ¦
*   ¦     Get 2 digit suffix of destination table       ¦
*   ¦                                                   ¦
*   +---------------------------------------------------+
*
CHKTAB   EQU   *
         MVC   WSTABLE(6),=C'XDITAB'
         MVC   WSTABLE+6(2),0(R2)
         OI    WSPFLAGS,WSPFTABL      Indicate table will be renew
         B     PARMNEXT               Get next parm
*
*   +---------------------------------------------------+
*   ¦                                                   ¦
*   ¦   Check CLASS or CLASSES Parameter                ¦
*   ¦     Get list of 1 to 8 sysout classes to be       ¦
*   ¦     a selection criteria                          ¦
*   ¦                                                   ¦
*   +---------------------------------------------------+
*
CHKCLS   EQU   *
         MVC   WSCLASSL,=8X'40'       Blank class list
         LA    R6,WSCLASSL            Point to target
         OI    WSPFLAGS,WSPFCLAS      Indicate that class parm done
         OI    WSPFLAGS,WSPFSSRQ      Indicate need re-SSREQ
         BAS   R14,COPYPARM           Perform copy parameter
         B     PARMNEXT               Get next parm
*
*   +---------------------------------------------------+
*   ¦                                                   ¦
*   ¦   Check RQCLASS Parameter                         ¦
*   ¦                                                   ¦
*   +---------------------------------------------------+
*
CHKRQC   EQU   *
         MVC   WSQCLASS,0(R2)         Get requeue class
         OI    WSQCLASS,C' '          Must uppercase
         B     PARMNEXT               Get next parm
*
*   +---------------------------------------------------+
*   ¦                                                   ¦
*   ¦   Check PCFORM Parameter                          ¦
*   ¦     Get default PC FORM to be used to create      ¦
*   ¦     flat dataset.   This parameter will be        ¦
*   ¦     overriden by one specified in the XDI         ¦
*   ¦     parmlib member.                               ¦
*   +---------------------------------------------------+
*
CHKFRM   EQU   *
         LA    R6,WSFORM              Point to target
         MVC   WSFORM,=CL8' '
         BAS   R14,COPYPARM           Copy the parm here
         CLC   =C'DISPATCH',WSFORM    Is FORM = DISPATCH ?
         BNE   WINDFRM                No, may be WINDOWS
         MVI   WSFFLAGS,WSFFDISP      Indicate FORM is DISPATCH
         B     OKEYFRM                Get next parm
WINDFRM  CLC   =C'WINDOWS',WSFORM     Is FORM = WINDOWS ?
         BNE   S390FRM                Get next parm
         MVI   WSFFLAGS,WSFFWIND      Indicate FORM is WINDOWS
         B     OKEYFRM                Get next parm
S390FRM  MVI   WSFFLAGS,WSFFS390      Indicate FORM is S/390 standard
OKEYFRM  EQU   *
         B     PARMNEXT               Get next parm
*
*   +---------------------------------------------------+
*   ¦                                                   ¦
*   ¦  Dynamic Data Copier                              ¦
*   ¦                                                   ¦
*   +---------------------------------------------------+
*
COPYPARM EQU   *
         CLI   0(R2),C' '             End of parm ?
         BE    COPYPEND               Yes, skip
         MVC   0(1,R6),0(R2)          Take 1 byte parm
         OI    0(R6),C' '             Make it uppercase
         LA    R6,1(,R6)              Next byte of target
         LA    R2,1(,R2)              Next byte of source
         BCT   R7,COPYPARM            Iterate
         BR    R14                    Return
COPYPEND EQU   *
         LA    R2,1(,R2)              Next byte of source
         BCTR  R7,0
         BR    R14                    Return
*
*   +---------------------------------------------------+
*   ¦                                                   ¦
*   ¦   Check DISP Parameter                            ¦
*   ¦     Get default sysout override disposition.      ¦
*   ¦     This parameter will be overriden by one       ¦
*   ¦     specified in the XDI parmlib member.          ¦
*   +---------------------------------------------------+
*
CHKDSP   EQU   *
         NI    WSOFLAGS,X'FF'-WSOFKEEP Clear indicator
         CLC   =C'KEEP',0(R2)         Is DISP=KEEP ?
         BE    OKEYDSPK               Handle if so
         CLC   =C'DELETE',0(R2)       Is DISP=DELETE ?
         BE    OKEYDSP                Handle if so
         B     PARM_ERROR             Otherwise, signal error msg
OKEYDSPK EQU   *
         OI    WSOFLAGS,WSOFKEEP      Indicate DISP=KEEP
OKEYDSP  EQU   *
         B     PARMNEXT               Get next parm
         SPACE
*
*   +---------------------------------------------------+
*   ¦                                                   ¦
*   ¦   Check DISP Parameter                            ¦
*   ¦     Get default flat dataset disposition to be    ¦
*   ¦     specified in file LCLDS01 of XCOMJOB.  This   ¦
*   ¦     parameter will be overriden by one specified  ¦
*   ¦     in the XDI parmlib member.                    ¦
*   +---------------------------------------------------+
*
CHKXDS   EQU   *
         NI    WSOFLAGS,X'FF'-WSOFXKEP Clear indicator
         CLC   =C'KEEP',0(R2)         Is XDISP=KEEP ?
         BE    OKEYXDSK               Handle if so
         CLC   =C'DELETE',0(R2)       Is XDISP=DELETE ?
         BE    OKEYXDS                Handle if so
         B     PARM_ERROR             Otherwise, signal error msg
OKEYXDSK EQU   *
         OI    WSOFLAGS,WSOFXKEP      Indicate XDISP=KEEP
OKEYXDS  EQU   *
         B     PARMNEXT               Get next parm
         SPACE ,
*
*   +---------------------------------------------------+
*   ¦                                                   ¦
*   ¦   Check HOLD Parameter                            ¦
*   ¦     Get default held sysout processing.  Specify  ¦
*   ¦     HOLD=PROCESS indicate that held sysout file   ¦
*   ¦     will be accecpted to XDI processing.  Other-  ¦
*   ¦     wise, HOLD=IGNORE is assumed.                 ¦
*   +---------------------------------------------------+
*
CHKHLD   EQU   *
         NI    WSOFLAGS,X'FF'-WSOFHOLD Clear indicator
         CLC   =C'PROCESS',0(R2)      Is HOLD=PROCESS ?
         BE    OKEYHLDK               Handle if so
         CLC   =C'IGNORE',0(R2)       Is HOLD=IGNORE ?
         BE    OKEYHLD                Handle if so
         B     PARM_ERROR
OKEYHLDK EQU   *
         OI    WSOFLAGS,WSOFHOLD      Indicate XDISP=KEEP
OKEYHLD  EQU   *
         OI    WSPFLAGS,WSPFSSRQ      Indicate need re-SSREQ
         B     PARMNEXT               Get next parm
*
*   +---------------------------------------------------+
*   ¦                                                   ¦
*   ¦   Check TRACE Parameter                           ¦
*   +---------------------------------------------------+
*
CHKTRC   EQU   *
         NI    WSOFLAGS,X'FF'-WSOFTRAC Clear indicator
         CLC   =C'OFF',0(R2)          Is TRACE=OFF ?
         BE    OKEYTRC                Handle if so
         CLC   =C'ON',0(R2)           Is TRACE=ON ?
         BE    OKEYTRCY               Handle if so
         CLC   =C'NO',0(R2)           Is TRACE=OFF ?
         BE    OKEYTRC                Handle if so
         CLC   =C'YES',0(R2)          Is TRACE=ON ?
         BE    OKEYTRCY               Handle if so
         CLC   =C'N',0(R2)            Is TRACE=OFF ?
         BE    OKEYTRC                Handle if so
         CLC   =C'Y',0(R2)            Is TRACE=ON ?
         BNE   PARMNEXT               No, get next parm
OKEYTRCY EQU   *
         OI    WSOFLAGS,WSOFTRAC      Indicate trace is on
OKEYTRC  EQU   *
         B     PARMNEXT               Get next parm
PARM_ERROR     EQU *
         L     R2,0(,R1)              Restore parm
         @MESSAGE ERROR,OPCODE=B,OBJECT=(R2),TYPE=PARM,                +
               RC=*,EXIT=EXIT
PARMNEXT EQU   *
         TM    WSPFLAGS,WSPFFILE      Is it parmlib processing ?
         BZ    PARMCONT
         L     R2,WSIOREC             Access record
         C     R2,WSIOREC+4           Is it overlimit ?
         BNH   PARM_REC               No, continue next record
         BAS   R14,GET_PARM           Yes, try another block
         @WTO  CODE=171,TRACE=ALWAYS
         B     RVEWPARM               Go here if no more block
PARMCONT EQU   *
         @WTO  CODE=170,TRACE=ALWAYS
         B     RVEWPARM               Go to review parameters
         EJECT
*
*   +---------------------------------------------------+
*   ¦                                                   ¦
*   ¦   Read Parameter Table (XDISYSnn)                 ¦
*   ¦     - All parameter can be specified in this      ¦
*   ¦       table                                       ¦
*   ¦     - Inline parameter will override this table   ¦
*   +---------------------------------------------------+
*
GET_PARM EQU *
         STM   R0,R15,WSSAVEGR
         B     READ_BLOCK
OPEN_PARM      EQU *
         STM   R0,R15,WSSAVEGR
         @WTO  CODE=135,TRACE=ALWAYS
         L     R8,ADDR_PARMLIB           Capture Parmlib DCB map
         L     R7,DCBDCBE                Establish PARMLIB DCBE map
         MVC   WSEOPARM,DCBEEODA         Save EODAD in WSA
         MVC   DCBEEODA,=A(EOF_PARMLIB)  Set EOF exit routine address
         TM    DCBOFLGS,DCBOFOPN         Is it opened ?
         BO    READ_PARM                 Yes, read parmlib block
         OPEN  ((R8),(INPUT)),MF=(E,LOPEN_PARMLIB),MODE=31 Open PARMLIB
         TM    DCBOFLGS,DCBOFOPN         Is it work ?
         BO    OPEN_PARM_OKEY
         @MESSAGE ERROR,OPCODE=BZ,RC=(R15),                            +
               OPER=IO,TYPE=OPEN,OBJECT=DCBDDNAM,                      +
               EXIT=*
         @MESSAGE ERROR,OPCODE=BZ,OBJECT=(R2),TYPE=PARM,               +
               RC=*,EXIT=EXIT
         B     EXIT
OPEN_PARM_OKEY EQU *
         OI    WSPFLAGS,WSPFOPEN         Remember parmlib opened
         L     R1,WSIOBUF                 and save in WSA
         A     R1,WSIOBUF+4              Save buffer length
         ST    R1,WSIOREC+4              Save address of end of buffer
READ_PARM      EQU *
         L     R8,ADDR_PARMLIB           Capture Parmlib DCB map
         FIND  ((R8)),WSPARMM,D          Find the member
         LTR   R15,R15                   Check RC
         BZ    READ_BLOCK                Begin to read if RC = 0
         @MESSAGE WARNING,OPCODE=BNZ,RC=(R15),                         +
               OPER=IO,TYPE=FIND,OBJECT=WSPARMM,                       +
               EXIT=*
         @MESSAGE WARNING,OPER=FIND,RC=(R15),                          +
               TYPE=PARM,OBJECT=WSPARMM,EXIT=EXIT
         B     EXIT
READ_BLOCK     EQU *
         L     R8,ADDR_PARMLIB           Capture Parmlib DCB map
         L     R5,WSIOBUF         Address of I/O buffer
         ST    R5,WSIOREC         Save 1st record address
         READ  XDIDECB,SF,(R8),(R5),'S',MF=E
         CHECK XDIDECB
         LH    R6,DCBLRECL        Get LRECL
         LH    R7,DCBBLKSI         and BLOCK SIZE
         LA    R7,0(R7,R5)        End of full block
         L     R1,XDIDECB+16      Address of IOB
         LH    R1,14(R1)          Residual count for short block
         SR    R7,R1              Adjust block length
         SR    R7,R6              Backward to the start of last record
         ST    R7,WSIOREC+4       Save address of last record
         LM    R0,R15,WSSAVEGR    Restore GPRs
         BR    R14                Return
EOF_PARMLIB    EQU   *
         L     R8,ADDR_PARMLIB           Capture Parmlib DCB map
         L     R7,DCBDCBE                Establish PARMLIB DCBE map
         MVC   DCBEEODA,WSEOPARM         Restore EODAD from WSA
RVEWPARM EQU   *
         @WTO  CODE=136,TRACE=ALWAYS
SHOWPARM EQU   *
         LA    R5,M_ENTRY
         TM    WSPFLAGS,WSPFFILE      Clear file indicator
         BZ    SHOW_CLASS
         LA    R5,M_FILE
         @MESSAGE INFO,OPER=SHOW,TYPE=PARMFILE,                        +
               OBJECT=WSPARMM
SHOW_CLASS     EQU *
         @MESSAGE INFO,OPER=SHOW,TYPE=CLASS,                           +
               OBJECT=WSCLASSL,TEXT=(R5)
         CLI   WSFFLAGS,WSFFDISP      PC form = Dispatch ?
         BE    SHOW_FORM
         CLI   WSFFLAGS,WSFFWIND      PC form = Windows ?
         BE    SHOW_FORM
         MVI   WSFFLAGS,WSFFS390      Otherwise, must be S/390
         MVC   WSFORM,=CL8'S/390'
SHOW_FORM      EQU *
         @MESSAGE INFO,OPER=SHOW,TYPE=PCFORM,                          +
               OBJECT=WSFORM,TEXT=(R5)
         MVC   WSDWORD,=CL8'KEEP'
         TM    WSOFLAGS,WSOFKEEP
         BO    SHOW_DISP
         MVC   WSDWORD,=CL8'DELETE'
SHOW_DISP      EQU *
         @MESSAGE INFO,OPER=SHOW,TYPE=DISP,                            +
               OBJECT=WSDWORD,TEXT=(R5)
         MVC   WSDWORD,=CL8'KEEP'
         TM    WSOFLAGS,WSOFXKEP
         BO    SHOW_XDISP
         MVC   WSDWORD,=CL8'DELETE'
SHOW_XDISP     EQU *
         @MESSAGE INFO,OPER=SHOW,TYPE=XDISP,                           +
               OBJECT=WSDWORD,TEXT=(R5)
         MVC   WSDWORD,=CL8'PROCESS'
         TM    WSOFLAGS,WSOFHOLD
         BO    SHOW_HOLD
         MVC   WSDWORD,=CL8'IGNORE'
SHOW_HOLD      EQU *
         @MESSAGE INFO,OPER=SHOW,TYPE=HOLDFILE,                        +
               OBJECT=WSDWORD,TEXT=(R5)
         MVC   WSWORD,=CL4'ON'
         TM    WSOFLAGS,WSOFTRAC
         BO    SHOW_TRACE
         MVC   WSWORD,=CL4'OFF'
SHOW_TRACE     EQU *
         @MESSAGE INFO,OPER=SHOW,TYPE=TRACE,                           +
               OBJECT=WSWORD,TEXT=(R5)
         B     EXIT
M_ENTRY  DC   AL2(L'MT_ENTRY)
MT_ENTRY DC   C'from direct entry  '
M_FILE   DC   AL2(L'MT_FILE)
MT_FILE  DC   C'from parmlib member  '
         EJECT
         DS   0H
         EJECT
*
*   +---------------------------------------------------+
*   ¦                                                   ¦
*   ¦   Read Destination Table (XDITABnn)               ¦
*   ¦     - Set of destination of recipient can only    ¦
*   ¦       specified via this table                    ¦
*   ¦     - There is no default for destinataion        ¦
*   +---------------------------------------------------+
*
UPDATE_TABLE  EQU *
         @WTO  CODE=172,TRACE=ALWAYS
         L     R8,ADDR_PARMLIB           Capture Parmlib DCB map
         L     R7,DCBDCBE                Establish PARMLIB DCBE map
         MVC   WSEOPARM,DCBEEODA         Save EODAD in WSA
         MVC   DCBEEODA,=A(EOF_TABLE)    Set EOF exit routine address
         TM    DCBOFLGS,DCBOFOPN         Is it opened ?
         BO    OPEN_TABLE_OKEY           Yes, read table block
         OPEN  ((R8),(INPUT)),MF=(E,LOPEN_PARMLIB),MODE=31 Open PARMLIB
         TM    DCBOFLGS,DCBOFOPN         Is it work ?
         BO    OPEN_TABLE_OKEY
         @MESSAGE ERROR,OPCODE=BZ,RC=(R15),                            +
               OPER=IO,TYPE=OPEN,OBJECT=WSTABLE,                       +
               EXIT=*
         @MESSAGE ERROR,OPCODE=BZ,OBJECT=(R2),TYPE=TABLE,              +
               RC=*,EXIT=EOF_TABLE
         B     EOF_TABLE
OPEN_TABLE_OKEY EQU *
         L     R8,ADDR_PARMLIB       Capture Parmlib DCB map
         FIND  ((R8)),WSTABLE,D      Check if TABLE name exist
         ST    R15,WSRCODE             Save RC
         LTR   R15,R15               Check RC
         BZ    READ_TABLE            Go straight if RC =  0
         @MESSAGE WARNING,OPCODE=BNZ,RC=(R15),                         +
               OPER=IO,TYPE=FIND,OBJECT=WSTABLE,                       +
               EXIT=*
         L     R15,WSRCODE           Restore RC
         @MESSAGE WARNING,OPER=FIND,RC=(R15),                          +
               TYPE=TABLE,OBJECT=WSTABLE,EXIT=*
         B     EOF_TABLE
READ_TABLE     EQU *
         LM    R2,R3,WSDESTP      Pointer and number of dest
         LTR   R2,R2              Has it initialized ?
         BZ    GET_VS_TABLE
         SLL   R3,3               Multiply to number of byte
         STORAGE RELEASE,ADDR=(R2),LENGTH=(R3)
GET_VS_TABLE   EQU *
         L     R3,WSIOBUF+4
         SLL   R3,1              At least 2 x I/O buffer
         STORAGE OBTAIN,LENGTH=(R3)
         ST    R1,WSDESTP         Save pointer
         SRL   R0,3               Divided by 8
         ST    R0,WSDESTP+4       and save it
*>>      TM    WSOFLAGS,WSOFTRAC  Is trace enabled ?
*>>      BZ    READ_BLOCK         Skip info msg if not
         @WTO  CODE=107,TRACE=ALWAYS Get parmlist address
         LM    R2,R3,WSDESTP      Top of table & # dest
READ_TABLE_BLOCK EQU *
         L     R5,WSIOBUF         Address of I/O buffer
         READ  XDIDECB,SF,(R8),(R5),'S',MF=E
         CHECK XDIDECB
         LH    R6,DCBLRECL        Get LRECL
         LH    R7,DCBBLKSI         and BLOCK SIZE
         LA    R7,0(R7,R5)        End of full block
         L     R1,XDIDECB+16      Address of IOB
         LH    R1,14(R1)          Residual count for short block
         SR    R7,R1              Adjust block length
         SR    R7,R6              Backward to the start of last record
READ_TABLE_RECORD EQU *
         CLI   0(R5),C'*'         Is comment ?
         BE    READ_TABLE_NEXT    Yes, skip this record
         CLI   0(R5),C' '         Is blank ?
         BE    READ_TABLE_NEXT    Yes, skip this record
         CLI   0(R5),X'00'        Is null ?
         BE    READ_TABLE_NEXT    Yes, skip this record
         MVC   0(8,R2),0(R5)      Get in the destination name
         LA    R2,8(,R2)          Next dest
         BCT   R3,READ_TABLE_NEXT
         L     R3,WSDESTP+4
         SLL   R3,4
         STORAGE OBTAIN,LENGTH=(R3)
         ST    R1,WSDWORD
         ST    R0,WSDWORD+4
         LR    R2,R1              Address
         LM    R0,R1,WSDESTP
         SLL   R1,3
         LR    R3,R1
MVCL_LOOP EQU  *
         MVCL  R2,R0
         LTR   R1,R1
         BC    1,MVCL_LOOP
         ST    R2,WSWORD          Position of unfilled new buffer
         LM    R2,R3,WSDESTP      Old table
         SLL   R3,3               Zoom to # bytes
         STORAGE RELEASE,ADDR=(R2),LENGTH=(R3)
         LM    R2,R3,WSDWORD      New table
         SRL   R3,3               # of dest
         STM   R2,R3,WSDESTP      Save new table
         L     R2,WSWORD          Resume position
         LR    R15,R2
         S     R15,WSDESTP        Offset
         L     R3,WSDWORD+4       Length of table
         SR    R3,R15             Length beyond last position
         SRL   R3,3               Rest # dest
READ_TABLE_NEXT EQU *
         BXLE  R5,R6,READ_TABLE_RECORD  Search next record in block
         B     READ_TABLE_BLOCK         Iterate to read next block
EOF_TABLE EQU  *
         MVC   0(8,R2),=CL8'/*EOF '
         NI    WSPFLAGS,X'FF'-WSPFTABL   Clear indicator
         MVC   WSDESTP1(8),WSDESTP      Set hot position
         MVC   DCBEEODA,WSEOPARM        Restore EODAD from WSA
         @WTO  CODE=173,TRACE=ALWAYS
*
*  +--------------------------------------------------------------+
*  |  Exit procedure                                              |
*  |    (1)  Tell JES that interaction is finished.               |
*  |    (2)  Free SSOB/SSSO storage area.                         |
*  |    (3)  Restore system savearea address                      |
*  |    (4)  Disconnect DERWTR and DERWTX                         |
*  |    (5)  Free WSA                                             |
*  |    (6)  Restore states                                       |
*  |    (7)  Return to MVS                                        |
*  |                                                              |
*  +--------------------------------------------------------------+
*
         DS    0H
EXIT     EQU   *
         TM    WSPFLAGS,WSPFTABL      Is update table requested ?
         BO    UPDATE_TABLE           Yes, handle it
QUIT     EQU   *
*        LM    R2,R3,WSIOBUF            I/O buffer address & size
*        STORAGE RELEASE,ADDR=(R2),LENGTH=(R3)   Release the buffer
         @EXIT
         LTORG ,
         EJECT
*
* +--------------------------------+
* | Working Storage Area Map       |
* | Used as working set and other  |
* | dynamic storages directory     |
* +--------------------------------+
*
         DERWSA
         EJECT ,
*
* +--------------------------------+
* | Module Extension Area Map      |
* | Used as a non reentrant part   |
* | of this module                 |
* +--------------------------------+
*
         DERWTX TYPE=DSECT
*
* +--------------------------------+
* | Command interaction buffer     |
* | used to interfacing operator   |
* | console transaction            |
* +--------------------------------+
*
         DERCIB TYPE=DSECT
*        @EPILOG
*
*   STANDARD MVS SOURCE COPY
*   FOR DSECTS AND EQUATES
*   ------------------------
*
         CVT   DSECT=YES
         DCBD  DSORG=(PO,PS)
         IHADCBE
         IEFJESCT TYPE=DSECT,MNTBL=YES
         IEFJSSOB (SO,AG,AL),CONTIG=YES
         IEFZB4D0
*        IEFZB4D2
         END   DERCOM
./ ADD NAME=DERDCB   0100-01324-01324-1743-00067-00067-00000-DERU-S
*
*
*                     +----------+
*     Module Name  -  ¦ DERDCB   ¦
*                     +----------+
*
*
*     Function -
*
*
*
*     Operating Environment -
*        Type              MVS System Program
*        Min. Auth.        Supervisor state
*        Dsp.unit mode     Task
*        AMODE             24-bit or 31-bit
*        XM                PASN=HASN=SASN
*        ASC mode          Primary
*        Interrupt status  Enabled for I/O and Ext. interrupts
*        Locks             No locks held
*        Control Parm      The SSOB and SSSO control blocks can
*                          reside in storage above 16 megabytes.
*        Recovery          Program should provide an ESTAE-type
*                          recovery environment. See MVS/ESA SP V5
*                          Auth Assembler Services Guide for more info
*                          an ESTAE-type recovery environment.
*
*
*
*
*
*     Syntax -
*
*
*     Operation -
*
*
*     Author -
*          Name     :  Deru Sudibyo
*                      Technical Consultant
*                      Computer Associates
*                      Indonesia Office
*                      Wisma BNI-46 34th floor, BNI-46 City
*                      Jl. Jend. Sudirman, Kav 1, Jakarta Pusat
*          Copyright:  (C)1998 Deru Sudibyo
*
*     Disclaimer -
*         This module is developed as a personal support, and is
*         not a part of CA support matterials.  The purpose is as
*         a temporary solution or even just a sample.  Therefor,
*         further modifications and maintenance are client's
*         responsibilities.
*
*     Modification Log -
*     +--------+------------+--------+---------------------------+
*     ¦ Date   ¦ Engineer   ¦ V.R.L. ¦ Description               ¦
*     +--------+------------+--------+---------------------------+
*     ¦98/02/12¦ Deru S.    ¦ 1.0.0. ¦ First development         ¦
*     ¦        ¦            ¦        ¦                           ¦
*     ¦        ¦            ¦        ¦                           ¦
*     ¦        ¦            ¦        ¦                           ¦
*     ¦        ¦            ¦        ¦                           ¦
*     ¦        ¦            ¦        ¦                           ¦
*     ¦        ¦            ¦        ¦                           ¦
*     +--------+------------+--------+---------------------------+
*
         DERDCB TYPE=CSECT,PRINT=GEN,RMODE=24,AMODE=31
./ ADD NAME=DERMSG   0100-01324-01324-1743-00067-00067-00000-DERU-S
*
*
*                     +----------+
*     Module Name  -  ¦ DERMSG   ¦
*                     +----------+
*
*
*     Function -
*
*
*
*     Operating Environment -
*        Type              MVS System Program
*        Min. Auth.        Supervisor state
*        Dsp.unit mode     Task
*        AMODE             24-bit or 31-bit
*        XM                PASN=HASN=SASN
*        ASC mode          Primary
*        Interrupt status  Enabled for I/O and Ext. interrupts
*        Locks             No locks held
*        Control Parm      The SSOB and SSSO control blocks can
*                          reside in storage above 16 megabytes.
*        Recovery          Program should provide an ESTAE-type
*                          recovery environment. See MVS/ESA SP V5
*                          Auth Assembler Services Guide for more info
*                          an ESTAE-type recovery environment.
*
*
*
*
*
*     Syntax -
*
*
*     Operation -
*
*
*     Author -
*          Name     :  Deru Sudibyo
*                      Technical Consultant
*                      Computer Associates
*                      Indonesia Office
*                      Wisma BNI-46 34th floor, BNI-46 City
*                      Jl. Jend. Sudirman, Kav 1, Jakarta Pusat
*          Copyright:  (C)1998 Deru Sudibyo
*
*     Disclaimer -
*         This module is developed as a personal support, and is
*         not a part of CA support matterials.  The purpose is as
*         a temporary solution or even just a sample.  Therefor,
*         further modifications and maintenance are client's
*         responsibilities.
*
*     Modification Log -
*     +--------+------------+--------+---------------------------+
*     ¦ Date   ¦ Engineer   ¦ V.R.L. ¦ Description               ¦
*     +--------+------------+--------+---------------------------+
*     ¦98/02/12¦ Deru S.    ¦ 1.0.0. ¦ First development         ¦
*     ¦        ¦            ¦        ¦                           ¦
*     ¦        ¦            ¦        ¦                           ¦
*     ¦        ¦            ¦        ¦                           ¦
*     ¦        ¦            ¦        ¦                           ¦
*     ¦        ¦            ¦        ¦                           ¦
*     ¦        ¦            ¦        ¦                           ¦
*     +--------+------------+--------+---------------------------+
*
         DERMSG TYPE=CSECT,PRINT=GEN
./ ADD NAME=DERWSA   0100-01324-01324-1743-00067-00067-00000-DERU-S
*
*
*                     +----------+
*     Module Name  -  ¦ DERWSA   ¦
*                     +----------+
*
*
*     Function -
*
*
*
*     Operating Environment -
*        Type              MVS System Program
*        Min. Auth.        Supervisor state
*        Dsp.unit mode     Task
*        AMODE             24-bit or 31-bit
*        XM                PASN=HASN=SASN
*        ASC mode          Primary
*        Interrupt status  Enabled for I/O and Ext. interrupts
*        Locks             No locks held
*        Control Parm      The SSOB and SSSO control blocks can
*                          reside in storage above 16 megabytes.
*        Recovery          Program should provide an ESTAE-type
*                          recovery environment. See MVS/ESA SP V5
*                          Auth Assembler Services Guide for more info
*                          an ESTAE-type recovery environment.
*
*
*
*
*
*     Syntax -
*
*
*     Operation -
*
*
*     Author -
*          Name     :  Deru Sudibyo
*                      Technical Consultant
*                      Computer Associates
*                      Indonesia Office
*                      Wisma BNI-46 34th floor, BNI-46 City
*                      Jl. Jend. Sudirman, Kav 1, Jakarta Pusat
*          Copyright:  (C)1998 Deru Sudibyo
*
*     Disclaimer -
*         This module is developed as a personal support, and is
*         not a part of CA support matterials.  The purpose is as
*         a temporary solution or even just a sample.  Therefor,
*         further modifications and maintenance are client's
*         responsibilities.
*
*     Modification Log -
*     +--------+------------+--------+---------------------------+
*     ¦ Date   ¦ Engineer   ¦ V.R.L. ¦ Description               ¦
*     +--------+------------+--------+---------------------------+
*     ¦98/02/12¦ Deru S.    ¦ 1.0.0. ¦ First development         ¦
*     ¦        ¦            ¦        ¦                           ¦
*     ¦        ¦            ¦        ¦                           ¦
*     ¦        ¦            ¦        ¦                           ¦
*     ¦        ¦            ¦        ¦                           ¦
*     ¦        ¦            ¦        ¦                           ¦
*     ¦        ¦            ¦        ¦                           ¦
*     +--------+------------+--------+---------------------------+
*
         DERWSA TYPE=CSECT,PRINT=GEN,AMODE=31,RMODE=24
./ ADD NAME=DERWTB   0100-01324-01324-1743-00581-00581-00000-DERU-S
**********************************************************************
*
*                     +---------+
*     Module Name  -  | DERWTB  |
*                     +---------+
*                     Local External Writer Component to Support
*                     CA-Dispatch and CA-XCOM Handshaking
*
*     Function -
*            Output writer routine to copy sysout into flat dataset
*            files and submit XCOMJOB.
*
*     Operating Environment -
*        Type              MVS System Program
*        Min. Auth.        Supervisor state
*        Dsp.unit mode     Task
*        AMODE             24-bit or 31-bit
*        XM                PASN=HASN=SASN
*        ASC mode          Primary
*        Interrupt status  Enabled for I/O and Ext. interrupts
*        Locks             No locks held
*        Control Parm      The SSOB and SSSO control blocks can
*                          reside in storage above 16 megabytes.
*        Recovery          Program should provide an ESTAE-type
*                          recovery environment. See MVS/ESA SP V5
*                          Auth Assembler Services Guide for more info
*                          an ESTAE-type recovery environment.
*
*
*     Syntax -
*          None
*
*     Operation -
*
*
*     Register Usage -
*          R0-R1   -->  System interface
*          R2-R6   -->  Work registers
*          R7      -->  DCB map (IHADCB) address of SYSOUT
*          R8      -->  DCB map (IHADCB) address of LCLDS01
*          R9      -->  Module extension base address
*          R10     -->  WSA (working storage area) address
*          R11     -->  Flat File record map
*          R12     -->  Main module base address
*          R13     -->  Conventional savearea
*          R14     -->  BAS or BASR return address
*          R15     -->  Return code
*
*     Author -
*          Name     :  Deru Sudibyo
*                      Technical Consultant
*                      Computer Associates
*                      Indonesia Office
*                      Wisma BNI-46 34th floor, BNI-46 City
*                      Jl. Jend. Sudirman, Kav 1, Jakarta Pusat
*          Copyright:  (C)1998 Deru Sudibyo
*
*     Disclaimer -
*         This module is developed as a personal support, and is
*         not a part of CA support matterials.  The purpose is as
*         a temporary solution or even just a sample.  Therefor,
*         further modifications and maintenance are client's
*         responsibilities.
*
*     Modification Log -
*     +--------+------------+--------+---------------------------+
*     | Date   | Engineer   | V.R.L. | Description               |
*     +--------+------------+--------+---------------------------+
*     |98/02/12| Deru S.    | 1.0.0. | First development         |
*     |        |            |        |                           |
*     |        |            |        |                           |
*     |        |            |        |                           |
*     |        |            |        |                           |
*     |        |            |        |                           |
*     |        |            |        |                           |
*     +--------+------------+--------+---------------------------+
*
*
         EJECT ,
DERWTB   @PROLOG ESA=390,                                              +
               AMODE=31,                                               +
               RMODE=24,                                               +
               RENT=YES,                                               +
               BREG=R12
*
         USING DCBE,R7            Establish DCBE structure map
         USING IHADCB,R8          Establish DCB structure map
         USING DERWTX,R9          Establish Module extension logic map
         USING WSA,R10            Establish WSA structure map
         USING FFRECMAP,R11       Establish Flat file record map
*
*        LR    R10,R1             Enable WSA map
*        L     R9,WSMODWTX        Enable WTX map
*
         LOAD  EP=DERWSA
         LR    R10,R0             Enable WSA addressability
         LOAD  EP=DERWTX
         LR    R9,R0              Enable WTX addressability
         LOAD  EP=DERDCB
         L     R8,ADDR_JES2FILE     Access DCB of JES2FILE
         L     R7,DCBDCBE
         CLC   =C'DCBE',0(R7)
         BE    INSTALL_EODA
         WTO   'DER999999E DCBE Lost before I/O process begun...!!!'
         LA    R15,12               Set RC = 12
         B     EXIT
INSTALL_EODA   EQU *
         MVC   DCBEODA,=AL3(SPOOL_END)
         MVC   DCBSYNA,=AL3(SPOOL_SYN)
         MVC   DCBEEODA,=A(SPOOL_END)
         MVC   DCBESYNA,=A(SPOOL_SYN)
         L     R8,ADDR_LCLDS01      Access DCB of LCLDS01
         L     R7,DCBDCBE
         MVC   DCBSYNA,=AL3(SPOOL_SYN)
         MVC   DCBESYNA,=A(SPOOL_SYN)
         L     R11,WSIOBUF          Record buffer
         XC    FFRRDW,FFRRDW
         XC    WSBLKPTR,WSBLKPTR
         XC    WSRECPTR,WSRECPTR
         EJECT ,
*
*  +--------------------------------------------------------------+
*  |  Process spoolfile (sysout) & flatfile (dataset)             |
*  |  (1)  Initialize flat file w/ 3 records CADS-type header.    |
*  |  (2)  Sysout is to be read into memory, record by record.    |
*  |       Check CC in 1st byte of each record.                   |
*  |  (3)  Write each spoolfile-record into flatfile record w/o   |
*  |       CC with the following rule:                            |
*  |         If CC = page-break then insert 3rd CADS-type header  |
*  |         record into flatfile.                                |
*  +--------------------------------------------------------------+
*
         DS    0H
PROCESS_SPOOL  EQU *
         @WTO  CODE=177
         L     $SYSOUT,ADDR_JES2FILE Access DCB of JES2FILE
         L     $FLATDS,ADDR_LCLDS01 Access DCB of LCLDS01
         TM    WSPFLAGS,WSPFOVER    Is form overriden ?
         BZ    PROCESS_STD          No, just take normal way
         CLI   WSOVFORM,WSFFS390    Is it S/390 standard format ?
         BE    PROCESS_S390         Yes, process it
         CLI   WSCC,WSCC_ASA        Is it ASA formatted sysout ?
         BNE   PROCESS_MCC          No, it should MCC format, handle it
         CLI   WSOVFORM,WSFFDISP    Is it Dispatch format ?
         BE    ASA_DISPATCH         Yes, process it
         CLI   WSOVFORM,WSFFWIND    Is it Windows format ?
         BE    ASA_WINDOWS          Yes, process it
         B     PROCESS_S390         Otherwise, assume standard
PROCESS_STD    EQU *
         CLI   WSFFLAGS,WSFFS390    Is it S/390 format ?
         BE    PROCESS_S390         Yes, process it
         CLI   WSCC,WSCC_ASA        Is it ASA formatted sysout ?
         BNE   PROCESS_MCC          No, it should MCC format, handle it
         CLI   WSFFLAGS,WSFFDISP    Is it Dispatch format ?
         BE    ASA_DISPATCH         Yes, process it
         CLI   WSFFLAGS,WSFFWIND    Is it Windows format ?
         BE    ASA_WINDOWS          Yes, process it
         B     PROCESS_S390         Otherwise, assume standard
*
ASA_DISPATCH   EQU *
         @WTO  CODE=178
         BAS   R6,DSP_HEADER       Build header
ASA_DSP_READ   EQU *
         BAS   R14,GET_RECORD       Get a logical record
         LA    R5,ASA_DSP_NEWPAGE   Return address if true
         BAS   R6,ASA_TEST_CHANNEL
         BAS   R6,ASA_TEST         Check all others
         B     ASA_DSP_READ         Interate
ASA_DSP_NEWPAGE EQU *
         BAS   R6,DSP_PAGE_HEADER Write page header
         BAS   R6,ASA_SPACE1       Write 1st line record
         B     ASA_DSP_READ         Interate
ASA_WINDOWS    EQU *
         @WTO  CODE=179
ASA_WIN_READ   EQU *
         BAS   R14,GET_RECORD JES2FILE Load sysout record
         LA    R5,ASA_WIN_NEWPAGE
         BAS   R6,ASA_TEST_CHANNEL
         BAS   R6,ASA_TEST         Check all others
         B     ASA_WIN_READ         Interate
ASA_WIN_NEWPAGE EQU *
         BAS   R14,CALC_LRECL       Calculate LRECL
         MVI   FFRDATA,X'0C'        Put page-break sign
         EX    R2,ASA_WIN_REC1
         PUT   ($FLATDS),FFREC LCLDS01 Store into flatfile
         B     ASA_WIN_READ         Interate
ASA_WIN_REC1   OC FFRDATA+1(*-*),0(R3) Move data from sysout buffer
ASA_TEST EQU   *
         CLI   0(R1),$ASA_SP1       Is it space 1 line ?
         BE    ASA_SPACE1           Yes, handle it
         CLI   0(R1),$ASA_SP2       Is it space 2 line ?
         BE    ASA_SPACE2           Yes, handle it
         CLI   0(R1),$ASA_SP3       Is it space 3 line ?
         BE    ASA_SPACE3           Yes, handle it
*        CLI   0(R1),$ASA_SP0       Is it suppress line ?
*        BER   R6                   Yes, ignore it
         BR    R6                   Interate
ASA_SPACE1     EQU *
         BAS   R14,CALC_LRECL       Calculate LRECL
         EX    R2,MOVE_FFREC
         PUT   ($FLATDS),FFREC LCLDS01 Store into flatfile
         BR    R6                   Interate
MOVE_FFREC     OC FFRDATA(*-*),0(R3) Move data from sysout buffer
ASA_SPACE2     EQU *
         LA    R4,1                 Do 1 x iteration
ASA_SPACE_LOOP EQU *
         MVC   FFRECLEN,=H'5'       This line is 1 byte space
         MVC   FFRDATA(8),=CL5' '
         PUT   ($FLATDS),FFREC LCLDS01 Store it into output file
         BCT   R4,ASA_SPACE_LOOP    Iterate
         B     ASA_SPACE1           Attempt to store record
ASA_SPACE3     EQU *
         LA    R4,2                 Do 2 x iteration
         B     ASA_SPACE_LOOP       Iterate
         SPACE ,
*
ASA_TEST_CHANNEL EQU *
         CLI   0(R1),$ASA_C01       Is it channel 1 skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$ASA_C02       Is it channel 2 skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$ASA_C03       Is it channel 3 skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$ASA_C04       Is it channel 4 skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$ASA_C05       Is it channel 5 skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$ASA_C06       Is it channel 6 skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$ASA_C07       Is it channel 7 skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$ASA_C08       Is it channel 8 skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$ASA_C09       Is it channel 9 skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$ASA_C10       Is it channel 10 skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$ASA_C11       Is it channel 11 skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$ASA_C12       Is it channel 12 skip ?
         BER   R5                   Yes, return
         BR    R6                   No, return to other gate
*
PROCESS_MCC    EQU *
         L     $SYSOUT,ADDR_JES2FILE Access DCB of JES2FILE
         L     $FLATDS,ADDR_LCLDS01 Access DCB of LCLDS01
         L     R11,WSIOBUF          Record buffer
         CLI   WSFFLAGS,WSFFDISP    Is it Dispatch format ?
         BNE   MCC_WINDOWS          No, it should Windows format
         @WTO  CODE=180
         BAS   R6,DSP_HEADER       Build header
MCC_DSP_EJECT  EQU *
         BAS   R6,DSP_PAGE_HEADER
MCC_DSP_READ   EQU *
         BAS   R14,GET_RECORD JES2FILE Load sysout record
         LA    R5,MCC_DSP_EJECT     Address to handle EJECTion
         BAS   R6,MCC_TEST_EJECT   Evaluate MCC
         LA    R5,MCC_DSP_EJECT     Address to handle EJECTion
         BAS   R6,MCC_TEST_CHANNEL Address to handle channel skipping
         BAS   R6,MCC_LINE         Handle other MCC
         B     MCC_DSP_READ         Interate
MCC_WINDOWS    EQU *
         @WTO  CODE=181
MCC_WIN_READ   EQU *
         BAS   R14,GET_RECORD JES2FILE Load sysout record
         LA    R5,MCC_WIN_EJECT     Address to handle EJECTion
         BAS   R6,MCC_TEST_EJECT   Evaluate MCC for EJECTion
         LA    R5,MCC_WIN_EJECT     Address to handle EJECTion
         BAS   R6,MCC_TEST_CHANNEL Address to handle channel skipping
         BAS   R6,MCC_LINE         Process other MCC
         B     MCC_WIN_READ         Interate
MCC_WIN_EJECT  EQU *
         BAS   R14,CALC_LRECL       Calculate LRECL
         BAS   R14,GET_RECORD JES2FILE Load sysout record
         EX    R2,MCC_WIN_MVC
         MVI   FFRDATA,X'0C'        Put page-break sign
         PUT   ($FLATDS),FFREC LCLDS01 Store into flatfile
         B     MCC_WIN_READ         Interate
MCC_WIN_MVC  OC FFRDATA+1(*-*),1(R1) Move data from sysout buffer
*
DSP_HEADER   EQU *
         XC    FFRRDW,FFRRDW
         MVC   FFRDATA(L'PH1),PH1
         LA    R2,L'PH1             Length of header 1
         STH   R2,FFRECLEN          Lrecl > DCB lrecl  ?
         PUT   ($FLATDS),FFREC LCLDS01 Store into flatfile
         MVC   FFRDATA(L'PH2),PH2
         LA    R2,L'PH2             Length of header 1
         STH   R2,FFRECLEN          Lrecl > DCB lrecl  ?
         PUT   ($FLATDS),FFREC LCLDS01 Store into flatfile
         BR    R6                   Return
DSP_PAGE_HEADER EQU *
         AP    WSPGNUM,=PL1'1'      Increment page number
         @EDITHDR UPDATE,LOC=*,     Edit page number                   +
               PAGENUM=(DEC,WSPGNUM),                                  +
               PREFIX=PH
         LA    R2,L'PH3             Length of header 3
         STH   R2,FFRECLEN          Put it on DCB
         MVC   FFRDATA(L'PH3),PH3   Lrecl > DCB lrecl  ?
         PUT   ($FLATDS),FFREC LCLDS01 Store into flatfile
         BR    R6                   Return
*  Notes:
*   The following MCC will affect to take action
*   after printing.
MCC_LINE EQU   *
         CLI   0(R1),$MCC_SP1       Is it space 1 line ?
         BE    MCC_SPACE1           Yes, handle it
         CLI   0(R1),$MCC_SP2       Is it space 2 line ?
         BE    MCC_SPACE2           Yes, handle it
         CLI   0(R1),$MCC_SP3       Is it space 3 line ?
         BE    MCC_SPACE3           Yes, handle it
         CLI   0(R1),$MCC_SP0       Is it print only line ?
         BNER  R6                   No, ignore it, return
MCC_SPACE0     EQU *
         LA    R4,1                 Do not iterate
         B     MCC_PRINT
MCC_SPACE1     EQU *
         LA    R4,1                 Do 1 x iteration
         B     MCC_PRINT
MCC_SPACE2     EQU *
         LA    R4,2                 Do 2 x iteration
         B     MCC_PRINT
MCC_SPACE3     EQU *
         LA    R4,3                 Do 3 x iteration
MCC_PRINT EQU  *
         BAS   R14,CALC_LRECL       Calculate LRECL
         EX    R2,MOVE_FFREC
         PUT   ($FLATDS),FFREC LCLDS01 Store sysout record into flatds
MCC_PRINT_SPACE EQU *
         BCT   R4,MCC_SPACE_LOOP
         BR    R6                   Interate
MCC_SPACE_LOOP EQU *
         MVC   FFRECLEN,=H'5'
         MVC   FFRDATA(8),=CL5' '   This line is 1 byte space
         PUT   ($FLATDS),FFREC LCLDS01 Store it into output file
         B     MCC_PRINT_SPACE      Iterate
         SPACE ,
*
MCC_TEST_CHANNEL EQU *
         CLI   0(R1),$MCC_C01       Is it channel 1 skip ?
         BE    MCC_PRINT_CHANNEL
         CLI   0(R1),$MCC_C02       Is it channel 2 skip ?
         BE    MCC_PRINT_CHANNEL
         CLI   0(R1),$MCC_C03       Is it channel 3 skip ?
         BE    MCC_PRINT_CHANNEL
         CLI   0(R1),$MCC_C04       Is it channel 4 skip ?
         BE    MCC_PRINT_CHANNEL
         CLI   0(R1),$MCC_C05       Is it channel 5 skip ?
         BE    MCC_PRINT_CHANNEL
         CLI   0(R1),$MCC_C06       Is it channel 6 skip ?
         BE    MCC_PRINT_CHANNEL
         CLI   0(R1),$MCC_C07       Is it channel 7 skip ?
         BE    MCC_PRINT_CHANNEL
         CLI   0(R1),$MCC_C08       Is it channel 8 skip ?
         BE    MCC_PRINT_CHANNEL
         CLI   0(R1),$MCC_C09       Is it channel 9 skip ?
         BE    MCC_PRINT_CHANNEL
         CLI   0(R1),$MCC_C10       Is it channel 10 skip ?
         BE    MCC_PRINT_CHANNEL
         CLI   0(R1),$MCC_C11       Is it channel 11 skip ?
         BE    MCC_PRINT_CHANNEL
         CLI   0(R1),$MCC_C12       Is it channel 12 skip ?
         BE    MCC_PRINT_CHANNEL
         BR    R6                   No, return to other gate
MCC_PRINT_CHANNEL EQU *
         LR    R6,R5                 Copy return address
         BAS   R14,CALC_LRECL       Calculate LRECL
         EX    R2,MOVE_FFREC
         PUT   ($FLATDS),FFREC LCLDS01 Store sysout record into flatds
         BR    R6                   Return
*
MCC_TEST_EJECT EQU *
         CLI   0(R1),$MCC_C01I      Is it channel 1 immediate skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$MCC_C02I      Is it channel 2 immediate skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$MCC_C03I      Is it channel 3 immediate skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$MCC_C04I      Is it channel 4 immediate skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$MCC_C05I      Is it channel 5 immediate skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$MCC_C06I      Is it channel 6 immediate skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$MCC_C07I      Is it channel 7 immediate skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$MCC_C08I      Is it channel 8 immediate skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$MCC_C09I      Is it channel 9 immediate skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$MCC_C10I      Is it channel 10 immediate skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$MCC_C11I      Is it channel 11 immediate skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$MCC_C12I      Is it channel 12 immediate skip ?
         BER   R5                   Yes, return
         BR    R6                   No, return to other gate
*
*  +----------------------------------------------+
*  ¦  GET a Record from Block of Data             ¦
*  ¦    - Just access last used record if any     ¦
*  ¦    - Else, issue GET (locate mode) to        ¦
*  ¦      obtain next block                       ¦
*  +----------------------------------------------+
*
GET_RECORD     EQU *
         L     R1,WSRECPTR          Get record address
         LTR   R1,R1                Any record there
         BNZ   GET_SV_RECORD
         ST    R14,WSREG14
         GET   ($SYSOUT)  JES2FILE  Load sysout record
         L     R14,WSREG14
         ST    R1,WSBLKPTR          Save block address
         CLI   2(R1),X'00'
         BNE   GET_NOTBLOK
         LH    R2,0(R1)             Get block length
         LA    R1,4(,R1)            Skip BDW
         ST    R1,WSRECPTR          Save record address
GET_SV_RECORD  EQU *
         XR    R4,R4
         ICM   R4,B'0011',0(R1)     Get record length
         STH   R4,WSLRECL           Save it
         XR    R0,R0
         L     R15,WSBLKPTR         Block pointer
         ICM   R0,B'0011',0(R15)    Get block length
         SR    R0,R4                Reduced by lrecl
         CH    R0,=H'4'             Is any record rest ?
         BH    GET_OKEY             Okey if at least 5
         XC    WSRECPTR,WSRECPTR    Otherwise, zap record pointer
         B     GET_FINISH           Then, return
GET_OKEY EQU   *
         LA    R2,0(R4,R1)          Address of next record
         ST    R2,WSRECPTR          Save here
GET_FINISH     EQU *
         LA    R1,4(R1)             Skip RDW
         LA    R3,1(R1)             Skip CC
         BR    R14                  Return
GET_NOTBLOK    EQU *
*        LH    R2,DCBLRECL
*        LA    R2,4(R2)
*        STH   R2,WSLRECL
         LA    R3,1(R1)             Skip CC
         BR    R14                  Return
GET_ERROR EQU  *
         WTO   'DER999999T Record not blocked ..... !!!!!!!'
         LA    R15,16               Set RC = 16
         B     EXIT
*
*  +-------------------------------------------------+
*  ¦                                                 ¦
*  ¦  Calculate LRECL of Input Dataset               ¦
*  ¦                                                 ¦
*  +-------------------------------------------------+
*
CALC_LRECL     EQU *
         LH    R2,DCBLRECL
         LA    R2,4(R2)             Add 5 for RDW + CC
         CH    R2,WSLRECL
         BNH   CALC_LRECL_GO
         LH    R2,WSLRECL           Use max 249
         CH    R2,=H'249'           Over long
         BNH   CALC_LRECL_GO        No,
         LH    R2,=H'249'           Use max 249
         B     CALC_LRECL_END       Finish
CALC_LRECL_GO  EQU *
         CH    R2,=H'5'             Is it under limit ?
         BNL   CALC_LRECL_OK        No, okey
         LH    R2,=H'5'             Yes, make it at least 4
         B     CALC_LRECL_END       Finish
CALC_LRECL_OK  EQU *
         LA    R2,1(R2)
CALC_LRECL_END EQU *
         STH   R2,FFRECLEN          Save Lrecl
         SH    R2,=H'5'             Back to original value - 1
         MVI   FFRDATA,C' '
         MVC   FFRDATA+1(256),FFRDATA
         BR    R14                  Return
*
*  +-------------------------------------------------+
*  ¦                                                 ¦
*  ¦  Process S/390 Standard Format Dataset          ¦
*  ¦                                                 ¦
*  +-------------------------------------------------+
*
PROCESS_S390   EQU *
         @WTO  CODE=182
         L     R8,ADDR_JES2FILE     Access DCB of JES2FILE
         GET   (R8)    JES2FILE     Load sysout record
         LR    R4,R1                Save record address
         LH    R5,DCBLRECL
         L     R8,ADDR_LCLDS01      Access DCB of LCLDS02
         PUT   (R8)         LCLDS02  Store sysout record into flatfile
         LR    R2,R1
         LH    R3,DCBLRECL
S390_LOOP EQU  *
         SH    R3,=H'5'
         CR    R3,R5
         BNH   S390_INPUT_LO
         LR    R3,R5
         B     S390_CHECK_MIN
S390_INPUT_LO  EQU *
         LR    R5,R3
S390_CHECK_MIN EQU *
         XC    0(4,R2),0(R2)        Zap RDW
         CH    R3,=H'5'             At least 5 byte, is it ?
         BH    S390_IN_TO_OUT       Yes, gohead
         LH    R3,=H'5'             No, make it 5
S390_IN_TO_OUT EQU *
         STH   R3,0(R2)             Set reclength
         LA    R2,4(,R2)            Jump over RDW
S390_MOVE_LOOP EQU *
         MVCL  R2,R4                Move input buf to output buf
         BC    1,S390_MOVE_LOOP     Loop if interrupted
         L     R8,ADDR_LCLDS01      Access DCB of LCLDS01
         PUT   (R8)         LCLDS02  Store sysout record into flatfile
         LR    R2,R1
         LH    R3,DCBLRECL
         L     R8,ADDR_JES2FILE     Access DCB of JES2FILE
         L     R7,DCBDCBE
         CLC   =C'DCBE',0(R7)
         BE    S390_GET_RECORD
         WTO   'DER999999E DCBE lost on the way ..... !!!!!!!!!!!'
         B     SPOOL_END
S390_GET_RECORD EQU *
         GET   (R8)    JES2FILE     Load sysout record
         LR    R4,R1                Save record address
         LH    R5,DCBLRECL
         L     R7,DCBDCBE
         B     S390_LOOP
*
SPOOL_SYN EQU *
         @WTO  CODE=148
         LA    R15,8                     Set RC = 8
         B     EXIT
SPOOL_END EQU *
         @WTO  CODE=183
         XR    R15,R15                   Set RC = 0
EXIT     EQU   *
         @EXIT
         LTORG ,
         EJECT
*
* +--------------------------------+
* | Working Storage Area Map       |
* | Used as working set and other  |
* | dynamic storages directory     |
* +--------------------------------+
*
         DERWSA
         EJECT ,
*
* +--------------------------------+
* | Module Extension Area Map      |
* | Used as a non reentrant part   |
* | of this module                 |
* +--------------------------------+
*
         DERWTX TYPE=DSECT
*
* +--------------------------------+
* | Flat File Record Area Map      |
* +--------------------------------+
*
FFRECMAP DERFFREC TYPE=DSECT
*
*   STANDARD MVS SOURCE COPY
*   FOR DSECTS AND EQUATES
*   ------------------------
*
         PRINT NOGEN
         DERTABCC
         CVT   DSECT=YES
         DCBD  DSORG=(PO,PS)
         IHADCBE
         IEFJESCT TYPE=DSECT,MNTBL=YES
         IEFJSSOB (SO,AG,AL),CONTIG=YES
         IEFZB4D0
*        IEFZB4D2
$FLATDS  EQU   7
$SYSOUT  EQU   8
         END   DERWTB
./ ADD NAME=DERWTG   0100-01324-01324-1743-00226-00226-00000-DERU-S
**********************************************************************
*
*                     +---------+
*     Module Name  -  | DERWTG  |
*                     +---------+
*                     Local External Writer Component to Support
*                     CA-Dispatch and CA-XCOM Handshaking
*
*     Function -
*            Output writer to through out unneeded sysout
*
*     Operating Environment -
*        Type              MVS System Program
*        Min. Auth.        Supervisor state
*        Dsp.unit mode     Task
*        AMODE             24-bit or 31-bit
*        XM                PASN=HASN=SASN
*        ASC mode          Primary
*        Interrupt status  Enabled for I/O and Ext. interrupts
*        Locks             No locks held
*        Control Parm      The SSOB and SSSO control blocks can
*                          reside in storage above 16 megabytes.
*        Recovery          Program should provide an ESTAE-type
*                          recovery environment. See MVS/ESA SP V5
*                          Auth Assembler Services Guide for more info
*                          an ESTAE-type recovery environment.
*
*
*     Syntax -
*          None
*
*     Operation -
*
*
*     Register Usage -
*          R0-R1   -->  System interface
*          R2-R7   -->  Work registers
*          R8      -->  DCB map (IHADCB) address
*          R9      -->  Module extension base address
*          R10     -->  WSA (working storage area) address
*          R11     -->  SSSO block address
*          R12     -->  Main module base address
*          R13     -->  Conventional savearea
*          R14     -->  BAS or BASR return address
*          R15     -->  Return code
*
*     Author -
*          Name     :  Deru Sudibyo
*                      Technical Consultant
*                      Computer Associates
*                      Indonesia Office
*                      Wisma BNI-46 34th floor, BNI-46 City
*                      Jl. Jend. Sudirman, Kav 1, Jakarta Pusat
*          Copyright:  (C)1998 Deru Sudibyo
*
*     Disclaimer -
*         This module is developed as a personal support, and is
*         not a part of CA support matterials.  The purpose is as
*         a temporary solution or even just a sample.  Therefor,
*         further modifications and maintenance are client's
*         responsibilities.
*
*     Modification Log -
*     +--------+------------+--------+---------------------------+
*     | Date   | Engineer   | V.R.L. | Description               |
*     +--------+------------+--------+---------------------------+
*     |98/02/12| Deru S.    | 1.0.0. | First development         |
*     |        |            |        |                           |
*     |        |            |        |                           |
*     |        |            |        |                           |
*     |        |            |        |                           |
*     |        |            |        |                           |
*     |        |            |        |                           |
*     +--------+------------+--------+---------------------------+
*
*
         EJECT ,
DERWTG   @PROLOG ESA=390,                                              +
               AMODE=31,                                               +
               RMODE=ANY,                                              +
               RENT=YES,                                               +
               BREG=R12
*
         USING DCBE,R7            Establish DCBE structure map
         USING IHADCB,R8          Establish DCB structure map
         USING DERWTX,R9          Establish Module extension logic map
         USING WSA,R10            Establish WSA structure map
         USING SSOB,R11           Establish SSOB structure map
*
*        LR    R10,R1             Enable WSA map
*        L     R9,WSMODWTX        Enable WTX map
*
         LR    R10,R1             Enable WSA addressability
         LOAD  EP=DERWSA
         LR    R10,R0             Enable WSA addressability
         L     R11,WSSSOB         Enable WSA addressability
         LOAD  EP=DERWTX
         LR    R9,R0              Enable WTX addressability
         LOAD  EP=DERDCB          Just to make sure DCB is floating
         @WTO  CODE=152              Get parmlist address
         @EDITTOD FORMAT=BOTH
         XC    WSRCODE,WSRCODE    Clear RC
*
*  +-----------------------------------------------------------+
*  ¦   Allocate JES2FILE                                       ¦
*  ¦      o  Type sysout                                       ¦
*  ¦      o  Input                                             ¦
*  ¦      o  Mapped by ARB & ARBP block in WTX                 ¦
*  ¦      o  DD name taken from DCB                            ¦
*  ¦                                                           ¦
*  +-----------------------------------------------------------+
*
ALLOC    EQU *
         L     R8,ADDR_SYSOUT         Access of sysout DCB
         L     R7,DCBDCBE               and DCBE
         MVC   DCBESYNA,=A(CLOSE)     Set SYNAD
         MVC   DCBEEODA,=A(CLOSE)     Set EODAD
         @DYNAMIC ALLOC,              Prepare sysout SVC 99 parm       +
               DSN=WSSODSN,           Copy DSN from SSSODSN            +
               PREFIX=A,              The prefix is A                  +
               GETDD=DCBDDNAM,        Copy DDname into JES2FILE's DCB  +
               ERRMSG=WTO,            Display error msg using WTO      +
               LOC=*                  Inline
         LTR   R15,R15                Check RC
         BZ    DEALLOC                Straight dealloc if RC = 0
         TM    WSSFLAGS,WSSFAJES      Is it already allocated ?
         BO    OPEN                   Yes, just reopen it
         A     R15,WSRCODE            Accumulate RC
         ST    R15,WSRCODE
         @MESSAGE ERROR,OPCODE=BNZ,OPER=DYNALLOC,TYPE=ALLOC,           +
               OBJECT=WSSODSN,RC=ARBERR,EXIT=DEALLOC
OPEN     EQU   *
         TM    DCBOFLGS,DCBOFOPN         Is it already opened ?
         BO    READ                      Yes, try to read a record ?
         OPEN  ((R8),(INPUT)),MODE=31,   Open DCB of sysout            +
               MF=(E,LOPEN)
         TM    DCBOFLGS,DCBOFOPN         Is it work ?
         BO    READ                      Yes, try to read
         A     R15,WSRCODE               Accumulate RC
         ST    R15,WSRCODE
         WTO   'DERWTG999E Open error for file JES2FILE'
         B     DEALLOC                   Then dealloc it
READ     EQU   *
         GET   (R8)                      Read a record
CLOSE    EQU   *
         CLOSE ((R8)),MODE=31,MF=(E,LCLOSE) Close sysout
         LTR   R15,R15                   Is it closed ?
         BZ    DEALLOC                   Yes, continue dealloc
         A     R15,WSRCODE               No, accumulate RC
         ST    R15,WSRCODE
         WTO   'DERXIO999E Close error for file JES2FILE'
DEALLOC  EQU   *
         @DYNAMIC FREE,               Prepare sysout SVC 99 parm       +
               PREFIX=D,              The prefix is D                  +
               DD=DCBDDNAM,                                            +
               ERRMSG=WTO,            Display error msg using WTO      +
               TOLFAIL=1080,          Tolerate 1080 error              +
               LOC=*                  Inline
         LTR   R15,R15                Check RC
         BZ    DEALLOC_OKEY
         TM    WSSFLAGS,WSSFAJES      Is it already allocated ?
         BZ    EXIT                   No, just exit
         A     R15,WSRCODE            Accumulate RC
         ST    R15,WSRCODE
         OI    WSEFLAGS,WSEFERRP      Remember this error
         @MESSAGE ERROR,OPCODE=B,OPER=DYNALLOC,TYPE=DEALLOC,           +
               OBJECT=WSSODSN,RC=DRBERR,EXIT=EXIT
DEALLOC_OKEY   EQU *
         NI    WSSFLAGS,X'FF'-WSSFAJES Turn indicator off
         B     EXIT                   Then skip NSI
*
* +--------------------------------+
* | EXIT Procedure                 |
* | Due to everything done, then   |
* | return to DERXDI               |
* +--------------------------------+
*
EXIT     EQU   *
         L     R15,WSRCODE              Get RC
         LTR   R15,R15                  Check
         BZ    EXIT01                   if RC = 0, skip msg
         @WTO  CODE=147
EXIT01   EQU   *
         @WTO  CODE=153              Get parmlist address
         TM    WSEFLAGS,WSEFERRP        Any serious error ?
         BZ    EXIT02                   No, just exit
         LA    R15,8                    Make RC = 8
         A     R15,WSRCODE              Accumulate RC
         ST    R15,WSRCODE
EXIT02   EQU   *
         L     R15,WSRCODE              Get RC
         @EXIT
         LTORG ,
         EJECT
*
* +--------------------------------+
* | Working Storage Area Map       |
* | Used as working set and other  |
* | dynamic storages directory     |
* +--------------------------------+
*
         DERWSA
         EJECT ,
*
* +--------------------------------+
* | Module Extension Area Map      |
* | Used as a non reentrant part   |
* | of this module                 |
* +--------------------------------+
*
         DERWTX TYPE=DSECT
*
*   STANDARD MVS SOURCE COPY
*   FOR DSECTS AND EQUATES
*   ------------------------
*
         PRINT NOGEN
         DERTABCC
         CVT   DSECT=YES
         DCBD  DSORG=(PO,PS)
         IHADCBE
         IEFJESCT TYPE=DSECT,MNTBL=YES
         IEFJSSOB (SO,AG,AL),CONTIG=YES
         IEFZB4D0
*        IEFZB4D2
         END   DERWTG
./ ADD NAME=DERWTR   0100-01324-01324-1743-00528-00528-00000-DERU-S
**********************************************************************
*
*                     +---------+
*     Module Name  -  | DERWTR  |
*                     +---------+
*                     Local External Writer Component to Support
*                     CA-Dispatch and CA-XCOM Handshaking
*
*     Function -
*            Output writer routine to copy sysout into flat dataset
*            files and submit XCOMJOB.
*
*     Operating Environment -
*        Type              MVS System Program
*        Min. Auth.        Supervisor state
*        Dsp.unit mode     Task
*        AMODE             24-bit or 31-bit
*        XM                PASN=HASN=SASN
*        ASC mode          Primary
*        Interrupt status  Enabled for I/O and Ext. interrupts
*        Locks             No locks held
*        Control Parm      The SSOB and SSSO control blocks can
*                          reside in storage above 16 megabytes.
*        Recovery          Program should provide an ESTAE-type
*                          recovery environment. See MVS/ESA SP V5
*                          Auth Assembler Services Guide for more info
*                          an ESTAE-type recovery environment.
*
*
*     Syntax -
*          None
*
*     Operation -
*
*
*     Register Usage -
*          R0-R1   -->  System interface
*          R2-R6   -->  Work registers
*          R7      -->  DCB map (IHADCB) address of SYSOUT
*          R8      -->  DCB map (IHADCB) address of LCLDS01
*          R9      -->  Module extension base address
*          R10     -->  WSA (working storage area) address
*          R11     -->  Flat File record map
*          R12     -->  Main module base address
*          R13     -->  Conventional savearea
*          R14     -->  BAS or BASR return address
*          R15     -->  Return code
*
*     Author -
*          Name     :  Deru Sudibyo
*                      Technical Consultant
*                      Computer Associates
*                      Indonesia Office
*                      Wisma BNI-46 34th floor, BNI-46 City
*                      Jl. Jend. Sudirman, Kav 1, Jakarta Pusat
*          Copyright:  (C)1998 Deru Sudibyo
*
*     Disclaimer -
*         This module is developed as a personal support, and is
*         not a part of CA support matterials.  The purpose is as
*         a temporary solution or even just a sample.  Therefor,
*         further modifications and maintenance are client's
*         responsibilities.
*
*     Modification Log -
*     +--------+------------+--------+---------------------------+
*     | Date   | Engineer   | V.R.L. | Description               |
*     +--------+------------+--------+---------------------------+
*     |98/02/12| Deru S.    | 1.0.0. | First development         |
*     |        |            |        |                           |
*     |        |            |        |                           |
*     |        |            |        |                           |
*     |        |            |        |                           |
*     |        |            |        |                           |
*     |        |            |        |                           |
*     +--------+------------+--------+---------------------------+
*
*
         EJECT ,
DERWTR   @PROLOG ESA=390,                                              +
               AMODE=31,                                               +
               RMODE=24,                                               +
               RENT=YES,                                               +
               BREG=R12
*
         USING DCBE,R7            Establish DCBE structure map
         USING IHADCB,R8          Establish DCB structure map
         USING DERWTX,R9          Establish Module extension logic map
         USING WSA,R10            Establish WSA structure map
         USING FFRECMAP,R11       Establish Flat file record map
*
*        LR    R10,R1             Enable WSA map
*        L     R9,WSMODWTX        Enable WTX map
*
         LOAD  EP=DERWSA
         LR    R10,R0             Enable WSA addressability
         LOAD  EP=DERWTX
         LR    R9,R0              Enable WTX addressability
         LOAD  EP=DERDCB
         L     R8,ADDR_JES2FILE     Access DCB of JES2FILE
         L     R7,DCBDCBE
         CLC   =C'DCBE',0(R7)
         BE    INSTALL_EODA
         WTO   'DER999999E DCBE Lost before I/O process begun...!!!'
         LA    R15,12                 Set RC = 12
         B     EXIT
INSTALL_EODA   EQU *
         MVC   DCBEODA,=AL3(SPOOL_END)
         MVC   DCBSYNA,=AL3(SPOOL_SYN)
         MVC   DCBEEODA,=A(SPOOL_END)
         MVC   DCBESYNA,=A(SPOOL_SYN)
         L     R8,ADDR_LCLDS01      Access DCB of LCLDS01
         L     R7,DCBDCBE
         MVC   DCBSYNA,=AL3(SPOOL_SYN)
         MVC   DCBESYNA,=A(SPOOL_SYN)
         L     R11,WSIOBUF          Record buffer
         XC    FFRRDW,FFRRDW
         EJECT ,
*
*  +--------------------------------------------------------------+
*  |  Process spoolfile (sysout) & flatfile (dataset)             |
*  |  (1)  Initialize flat file w/ 3 records CADS-type header.    |
*  |  (2)  Sysout is to be read into memory, record by record.    |
*  |       Check CC in 1st byte of each record.                   |
*  |  (3)  Write each spoolfile-record into flatfile record w/o   |
*  |       CC with the following rule:                            |
*  |         If CC = page-break then insert 3rd CADS-type header  |
*  |         record into flatfile.                                |
*  +--------------------------------------------------------------+
*
         DS    0H
PROCESS_SPOOL  EQU *
         @WTO  CODE=177
         L     $SYSOUT,ADDR_JES2FILE Access DCB of JES2FILE
         L     $FLATDS,ADDR_LCLDS01 Access DCB of LCLDS01
         TM    WSPFLAGS,WSPFOVER    Is form overriden ?
         BZ    PROCESS_STD          No, just take normal way
         CLI   WSOVFORM,WSFFS390    Is it S/390 standard format ?
         BE    PROCESS_S390         Yes, process it
         CLI   WSCC,WSCC_ASA        Is it ASA formatted sysout ?
         BNE   PROCESS_MCC          No, it should MCC format, handle it
         CLI   WSOVFORM,WSFFDISP    Is it Dispatch format ?
         BE    ASA_DISPATCH         Yes, process it
         CLI   WSOVFORM,WSFFWIND    Is it Windows format ?
         BE    ASA_WINDOWS          Yes, process it
         B     PROCESS_S390         Otherwise, assume standard
PROCESS_STD    EQU *
         CLI   WSFFLAGS,WSFFS390    Is it S/390 format ?
         BE    PROCESS_S390         Yes, process it
         CLI   WSCC,WSCC_ASA        Is it ASA formatted sysout ?
         BNE   PROCESS_MCC          No, it should MCC format, handle it
         CLI   WSFFLAGS,WSFFDISP    Is it Dispatch format ?
         BE    ASA_DISPATCH         Yes, process it
         CLI   WSFFLAGS,WSFFWIND    Is it Windows format ?
         BE    ASA_WINDOWS          Yes, process it
         B     PROCESS_S390         Otherwise, assume standard
*
ASA_DISPATCH   EQU *
         @WTO  CODE=178
         BAS   R6,DSP_HEADER       Build header
ASA_DSP_READ   EQU *
         GET   ($SYSOUT)  JES2FILE  Load sysout record
         LA    R3,1(,R1)            Save record address
         LA    R5,ASA_DSP_NEWPAGE   Return address if true
         BAS   R6,ASA_TEST_CHANNEL
         BAS   R6,ASA_TEST         Check all others
         B     ASA_DSP_READ         Interate
ASA_DSP_NEWPAGE EQU *
         BAS   R6,DSP_PAGE_HEADER Write page header
         BAS   R6,ASA_SPACE1       Write 1st line record
         B     ASA_DSP_READ         Interate
ASA_WINDOWS    EQU *
         @WTO  CODE=179
ASA_WIN_READ   EQU *
         GET   ($SYSOUT) JES2FILE   Load sysout record
         LA    R3,1(,R1)            Save record address
         LA    R5,ASA_WIN_NEWPAGE
         BAS   R6,ASA_TEST_CHANNEL
         BAS   R6,ASA_TEST         Check all others
         B     ASA_WIN_READ         Interate
ASA_WIN_NEWPAGE EQU *
         BAS   R14,CALC_LRECL       Calculate LRECL
         MVI   FFRDATA,X'0C'        Put page-break sign
         EX    R2,ASA_WIN_REC1
         PUT   ($FLATDS),FFREC LCLDS01 Store into flatfile
         B     ASA_WIN_READ         Interate
ASA_WIN_REC1  OC FFRDATA+1(*-*),0(R3) Move data from sysout buffer
ASA_TEST EQU   *
         CLI   0(R1),$ASA_SP1       Is it space 1 line ?
         BE    ASA_SPACE1           Yes, handle it
         CLI   0(R1),$ASA_SP2       Is it space 2 line ?
         BE    ASA_SPACE2           Yes, handle it
         CLI   0(R1),$ASA_SP3       Is it space 3 line ?
         BE    ASA_SPACE3           Yes, handle it
*        CLI   0(R1),$ASA_SP0       Is it suppress line ?
*        BER   R6                   Yes, ignore it
         BR    R6                   Interate
ASA_SPACE1     EQU *
         BAS   R14,CALC_LRECL       Calculate LRECL
         EX    R2,MOVE_FFREC
         PUT   ($FLATDS),FFREC LCLDS01 Store into flatfile
         BR    R6                   Interate
MOVE_FFREC     OC  FFRDATA(*-*),0(R3) Move data from sysout buffer
ASA_SPACE2     EQU *
         LA    R4,1                 Do 1 x iteration
ASA_SPACE_LOOP EQU *
         MVC   FFRECLEN,=H'5'       This line is 1 byte space
         MVC   FFRDATA(8),=CL5' '
         PUT   ($FLATDS),FFREC LCLDS01 Store it into output file
         BCT   R4,ASA_SPACE_LOOP    Iterate
         B     ASA_SPACE1           Attempt to store record
ASA_SPACE3     EQU *
         LA    R4,2                 Do 2 x iteration
         B     ASA_SPACE_LOOP       Iterate
         SPACE ,
*
ASA_TEST_CHANNEL EQU *
         CLI   0(R1),$ASA_C01       Is it channel 1 skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$ASA_C02       Is it channel 2 skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$ASA_C03       Is it channel 3 skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$ASA_C04       Is it channel 4 skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$ASA_C05       Is it channel 5 skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$ASA_C06       Is it channel 6 skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$ASA_C07       Is it channel 7 skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$ASA_C08       Is it channel 8 skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$ASA_C09       Is it channel 9 skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$ASA_C10       Is it channel 10 skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$ASA_C11       Is it channel 11 skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$ASA_C12       Is it channel 12 skip ?
         BER   R5                   Yes, return
         BR    R6                   No, return to other gate
*
PROCESS_MCC    EQU *
         CLI   WSFFLAGS,WSFFDISP    Is it Dispatch format ?
         BNE   MCC_WINDOWS          No, it should Windows format
         @WTO  CODE=180
         BAS   R6,DSP_HEADER       Build header
MCC_DSP_EJECT  EQU *
         BAS   R6,DSP_PAGE_HEADER
MCC_DSP_READ   EQU *
         GET   ($SYSOUT) JES2FILE   Load sysout record
         LA    R3,1(,R1)            Save record address
         LA    R5,MCC_DSP_EJECT     Address to handle EJECTion
         BAS   R6,MCC_TEST_EJECT   Evaluate MCC
         LA    R5,MCC_DSP_EJECT     Address to handle EJECTion
         BAS   R6,MCC_TEST_CHANNEL Address to handle channel skipping
         BAS   R6,MCC_LINE         Handle other MCC
         B     MCC_DSP_READ         Interate
MCC_WINDOWS    EQU *
         @WTO  CODE=181
MCC_WIN_READ   EQU *
         GET   ($SYSOUT) JES2FILE   Load sysout record
         LA    R3,1(,R1)            Save record address
         LA    R5,MCC_WIN_EJECT     Address to handle EJECTion
         BAS   R6,MCC_TEST_EJECT   Evaluate MCC for EJECTion
         LA    R5,MCC_WIN_EJECT     Address to handle EJECTion
         BAS   R6,MCC_TEST_CHANNEL Address to handle channel skipping
         BAS   R6,MCC_LINE         Process other MCC
         B     MCC_WIN_READ         Interate
MCC_WIN_EJECT  EQU *
         BAS   R14,CALC_LRECL       Calculate LRECL
         GET   ($SYSOUT) JES2FILE   Load sysout record
         EX    R2,MCC_WIN_MVC
         MVI   FFRDATA,X'0C'        Put page-break sign
         PUT   ($FLATDS),FFREC LCLDS01 Store into flatfile
         B     MCC_WIN_READ         Interate
MCC_WIN_MVC    OC  FFRDATA+1(*-*),1(R1) Move data from sysout buffer
*
DSP_HEADER   EQU *
         XC    FFRRDW,FFRRDW
         L     $FLATDS,ADDR_LCLDS01   Access DCB of LCLDS01
         MVC   FFRDATA(L'PH1),PH1
         LA    R2,L'PH1             Length of header 1
         STH   R2,FFRECLEN          Lrecl > DCB lrecl  ?
         PUT   ($FLATDS),FFREC LCLDS01 Store into flatfile
         MVC   FFRDATA(L'PH2),PH2
         LA    R2,L'PH2             Length of header 1
         STH   R2,FFRECLEN          Lrecl > DCB lrecl  ?
         PUT   ($FLATDS),FFREC LCLDS01 Store into flatfile
         BR    R6                   Return
DSP_PAGE_HEADER EQU *
         AP    WSPGNUM,=PL1'1'      Increment page number
         @EDITHDR UPDATE,LOC=*,     Edit page number                   +
               PAGENUM=(DEC,WSPGNUM),                                  +
               PREFIX=PH
         LA    R2,L'PH3             Length of header 3
         STH   R2,FFRECLEN          Put it on DCB
         MVC   FFRDATA(L'PH3),PH3   Lrecl > DCB lrecl  ?
         PUT   ($FLATDS),FFREC LCLDS01 Store into flatfile
         BR    R6                   Return
*  Notes:
*   The following MCC will affect to take action
*   after printing.
MCC_LINE EQU   *
         CLI   0(R1),$MCC_SP1       Is it space 1 line ?
         BE    MCC_SPACE1           Yes, handle it
         CLI   0(R1),$MCC_SP2       Is it space 2 line ?
         BE    MCC_SPACE2           Yes, handle it
         CLI   0(R1),$MCC_SP3       Is it space 3 line ?
         BE    MCC_SPACE3           Yes, handle it
         CLI   0(R1),$MCC_SP0       Is it print only line ?
         BNER  R6                   No, ignore it, return
MCC_SPACE0     EQU *
         LA    R4,1                 Do not iterate
         B     MCC_PRINT
MCC_SPACE1     EQU *
         LA    R4,1                 Do 1 x iteration
         B     MCC_PRINT
MCC_SPACE2     EQU *
         LA    R4,2                 Do 2 x iteration
         B     MCC_PRINT
MCC_SPACE3     EQU *
         LA    R4,3                 Do 3 x iteration
MCC_PRINT EQU  *
         BAS   R14,CALC_LRECL       Calculate LRECL
         EX    R2,MOVE_FFREC
         PUT   ($FLATDS),FFREC LCLDS01 Store sysout record into flatds
MCC_PRINT_SPACE EQU *
         BCT   R4,MCC_SPACE_LOOP
         BR    R6                   Interate
MCC_SPACE_LOOP EQU *
         MVC   FFRECLEN,=H'5'
         MVC   FFRDATA(8),=CL5' '   This line is 1 byte space
         PUT   ($FLATDS),FFREC LCLDS01 Store it into output file
         B     MCC_PRINT_SPACE      Iterate
         SPACE ,
*
MCC_TEST_CHANNEL EQU *
         CLI   0(R1),$MCC_C01       Is it channel 1 skip ?
         BE    MCC_PRINT_CHANNEL
         CLI   0(R1),$MCC_C02       Is it channel 2 skip ?
         BE    MCC_PRINT_CHANNEL
         CLI   0(R1),$MCC_C03       Is it channel 3 skip ?
         BE    MCC_PRINT_CHANNEL
         CLI   0(R1),$MCC_C04       Is it channel 4 skip ?
         BE    MCC_PRINT_CHANNEL
         CLI   0(R1),$MCC_C05       Is it channel 5 skip ?
         BE    MCC_PRINT_CHANNEL
         CLI   0(R1),$MCC_C06       Is it channel 6 skip ?
         BE    MCC_PRINT_CHANNEL
         CLI   0(R1),$MCC_C07       Is it channel 7 skip ?
         BE    MCC_PRINT_CHANNEL
         CLI   0(R1),$MCC_C08       Is it channel 8 skip ?
         BE    MCC_PRINT_CHANNEL
         CLI   0(R1),$MCC_C09       Is it channel 9 skip ?
         BE    MCC_PRINT_CHANNEL
         CLI   0(R1),$MCC_C10       Is it channel 10 skip ?
         BE    MCC_PRINT_CHANNEL
         CLI   0(R1),$MCC_C11       Is it channel 11 skip ?
         BE    MCC_PRINT_CHANNEL
         CLI   0(R1),$MCC_C12       Is it channel 12 skip ?
         BE    MCC_PRINT_CHANNEL
         BR    R6                   No, return to other gate
MCC_PRINT_CHANNEL EQU *
         LR    R6,R5                 Copy return address
         BAS   R14,CALC_LRECL       Calculate LRECL
         EX    R2,MOVE_FFREC
         PUT   ($FLATDS),FFREC LCLDS01 Store sysout record into flatds
         BR    R6                   Return
*
MCC_TEST_EJECT EQU *
         CLI   0(R1),$MCC_C01I      Is it channel 1 immediate skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$MCC_C02I      Is it channel 2 immediate skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$MCC_C03I      Is it channel 3 immediate skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$MCC_C04I      Is it channel 4 immediate skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$MCC_C05I      Is it channel 5 immediate skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$MCC_C06I      Is it channel 6 immediate skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$MCC_C07I      Is it channel 7 immediate skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$MCC_C08I      Is it channel 8 immediate skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$MCC_C09I      Is it channel 9 immediate skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$MCC_C10I      Is it channel 10 immediate skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$MCC_C11I      Is it channel 11 immediate skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$MCC_C12I      Is it channel 12 immediate skip ?
         BER   R5                   Yes, return
         BR    R6                   No, return to other gate
*
*  +-------------------------------------------------+
*  ¦                                                 ¦
*  ¦  Calculate LRECL of Input Dataset               ¦
*  ¦                                                 ¦
*  +-------------------------------------------------+
*
CALC_LRECL     EQU *
         LH    R2,DCBLRECL          Set lrecl
         LA    R2,4(R2)             skip RDW
         CH    R2,WSLRECL           Overlength of MVC ?
         BNH   LRECL_GO
         LH    R2,WSLRECL           Use max 249
         B     LRECL_OK
LRECL_GO EQU   *
         LA    R2,1(,R2)            Safeguard
LRECL_OK EQU   *
         STH   R2,FFRECLEN          Save Lrecl
         SH    R2,=H'6'             Back to original value - 1
         MVI   FFRDATA,C' '
         MVC   FFRDATA+1(256),FFRDATA
*        L     R7,DCBDCBE
*        CLC   =C'DCBE',0(R7)
*        BER   R14
*        WTO   'DER999999E DCBE Lost during I/O process ...!!!'
*        B     EXIT
         BR    R14                  Return
*
*  +-------------------------------------------------+
*  ¦                                                 ¦
*  ¦  Process S/390 Standard Format Dataset          ¦
*  ¦                                                 ¦
*  +-------------------------------------------------+
*
PROCESS_S390   EQU *
         @WTO  CODE=182
         L     R8,ADDR_JES2FILE     Access DCB of JES2FILE
         GET   (R8)    JES2FILE     Load sysout record
         LR    R4,R1                Save record address
         LH    R5,DCBLRECL
         L     R8,ADDR_LCLDS01      Access DCB of LCLDS02
         PUT   (R8)         LCLDS02  Store sysout record into flatfile
         LR    R2,R1
         LH    R3,DCBLRECL
S390_LOOP EQU  *
         SH    R3,=H'5'
         CR    R3,R5
         BNH   S390_INPUT_LO
         LR    R3,R5
         B     S390_CHECK_MIN
S390_INPUT_LO  EQU *
         LR    R5,R3
S390_CHECK_MIN EQU *
         XC    0(4,R2),0(R2)        Zap RDW
         CH    R3,=H'5'             At least 5 byte, is it ?
         BH    S390_IN_TO_OUT       Yes, gohead
         LH    R3,=H'5'             No, make it 5
S390_IN_TO_OUT EQU *
         STH   R3,0(R2)             Set reclength
         LA    R2,4(,R2)            Jump over RDW
S390_MOVE_LOOP EQU *
         MVCL  R2,R4                Move input buf to output buf
         BC    1,S390_MOVE_LOOP     Loop if interrupted
         L     R8,ADDR_LCLDS01      Access DCB of LCLDS01
         PUT   (R8)         LCLDS02  Store sysout record into flatfile
         LR    R2,R1
         LH    R3,DCBLRECL
         L     R8,ADDR_JES2FILE     Access DCB of JES2FILE
         L     R7,DCBDCBE
         CLC   =C'DCBE',0(R7)
         BE    S390_GET_RECORD
         WTO   'DER999999E DCBE lost on the way ..... !!!!!!!!!!!'
         B     SPOOL_END
S390_GET_RECORD EQU *
         GET   (R8)    JES2FILE     Load sysout record
         LR    R4,R1                Save record address
         LH    R5,DCBLRECL
         L     R7,DCBDCBE
         B     S390_LOOP
*
SPOOL_SYN EQU *
         @WTO  CODE=148
         LA    R15,8               Set RC = 8
         B     EXIT                Exit
SPOOL_END EQU *
         @WTO  CODE=183
         XR    R15,R15             Set RC = 0
EXIT     EQU   *
         @EXIT
         LTORG ,
         EJECT
*
* +--------------------------------+
* | Working Storage Area Map       |
* | Used as working set and other  |
* | dynamic storages directory     |
* +--------------------------------+
*
         DERWSA
         EJECT ,
*
* +--------------------------------+
* | Module Extension Area Map      |
* | Used as a non reentrant part   |
* | of this module                 |
* +--------------------------------+
*
         DERWTX TYPE=DSECT
*
* +--------------------------------+
* | Flat File Record Area Map      |
* +--------------------------------+
*
FFRECMAP DERFFREC TYPE=DSECT
*
*   STANDARD MVS SOURCE COPY
*   FOR DSECTS AND EQUATES
*   ------------------------
*
         PRINT NOGEN
         DERTABCC
         CVT   DSECT=YES
         DCBD  DSORG=(PO,PS)
         IHADCBE
         IEFJESCT TYPE=DSECT,MNTBL=YES
         IEFJSSOB (SO,AG,AL),CONTIG=YES
         IEFZB4D0
*        IEFZB4D2
$FLATDS  EQU   7
$SYSOUT  EQU   8
         END   DERWTR
./ ADD NAME=DERWTX   0100-01324-01324-1743-00068-00068-00000-DERU-S
*
*
*                     +----------+
*     Module Name  -  ¦ DERWTX   ¦
*                     +----------+
*
*
*     Function -
*
*
*
*     Operating Environment -
*        Type              MVS System Program
*        Min. Auth.        Supervisor state
*        Dsp.unit mode     Task
*        AMODE             24-bit or 31-bit
*        XM                PASN=HASN=SASN
*        ASC mode          Primary
*        Interrupt status  Enabled for I/O and Ext. interrupts
*        Locks             No locks held
*        Control Parm      The SSOB and SSSO control blocks can
*                          reside in storage above 16 megabytes.
*        Recovery          Program should provide an ESTAE-type
*                          recovery environment. See MVS/ESA SP V5
*                          Auth Assembler Services Guide for more info
*                          an ESTAE-type recovery environment.
*
*
*
*
*
*     Syntax -
*
*
*     Operation -
*
*
*     Author -
*          Name     :  Deru Sudibyo
*                      Technical Consultant
*                      Computer Associates
*                      Indonesia Office
*                      Wisma BNI-46 34th floor, BNI-46 City
*                      Jl. Jend. Sudirman, Kav 1, Jakarta Pusat
*          Copyright:  (C)1998 Deru Sudibyo
*
*     Disclaimer -
*         This module is developed as a personal support, and is
*         not a part of CA support matterials.  The purpose is as
*         a temporary solution or even just a sample.  Therefor,
*         further modifications and maintenance are client's
*         responsibilities.
*
*     Modification Log -
*     +--------+------------+--------+---------------------------+
*     ¦ Date   ¦ Engineer   ¦ V.R.L. ¦ Description               ¦
*     +--------+------------+--------+---------------------------+
*     ¦98/02/12¦ Deru S.    ¦ 1.0.0. ¦ First development         ¦
*     ¦        ¦            ¦        ¦                           ¦
*     ¦        ¦            ¦        ¦                           ¦
*     ¦        ¦            ¦        ¦                           ¦
*     ¦        ¦            ¦        ¦                           ¦
*     ¦        ¦            ¦        ¦                           ¦
*     ¦        ¦            ¦        ¦                           ¦
*     +--------+------------+--------+---------------------------+
*
         DERWTX TYPE=CSECT,PRINT=GEN,AMODE=31,RMODE=24
*        DERWSA
./ ADD NAME=DERXDI   0100-01324-01324-1743-01012-01012-00000-DERU-S
**********************************************************************
*
*                     +---------+
*     Module Name  -  | DERXDI  |
*                     +---------+
*                     CA-Dispatch -to- CA-XCOM Handshaking Interface
*
*     Function -
*            Activate local external writer and establish handshaking
*            between CA-Dispatch and CA-Xcom
*
*     Operating Environment -
*        Type              MVS System Program
*        Min. Auth.        Supervisor state
*        Dsp.unit mode     Task
*        AMODE             24-bit or 31-bit
*        XM                PASN=HASN=SASN
*        ASC mode          Primary
*        Interrupt status  Enabled for I/O and Ext. interrupts
*        Locks             No locks held
*        Control Parm      The SSOB and SSSO control blocks can
*                          reside in storage above 16 megabytes.
*        Recovery          Program should provide an ESTAE-type
*                          recovery environment. See MVS/ESA SP V5
*                          Auth Assembler Services Guide for more info
*                          an ESTAE-type recovery environment.
*
*
*     Syntax -
*          In Cataloged Procedure JCL
*
*  |           //stepname EXEC PGM=DERXDI,                           |
*  |           //            PARM='CLASSES=cccccccc,FORM=ffffffff'   |
*  |               cccccccc = List up to 8 classes to be captured    |
*  |               ffffffff = Form of recipient, i.e. FORM=DISPATCH  |
*  |                                                                 |
*          Or From Console Interaction
*  |                                                                 |
*  |           F Procname,Classes={ccccc}                            |
*
*
*     Operation -
*
*
*     Register Usage -
*          R0-R1   -->  System interface
*          R2-R7   -->  Work registers
*          R8      -->  DCB map (IHADCB) address
*          R9      -->  Module extension base address
*          R10     -->  WSA (working storage area) address
*          R11     -->  SSSO block address
*          R12     -->  Main module base address
*          R13     -->  Conventional savearea
*          R14     -->  BAS or BASR return address
*          R15     -->  Return code
*
*     Author -
*          Name     :  Deru Sudibyo
*                      Technical Consultant
*                      Computer Associates
*                      Indonesia Office
*                      Wisma BNI-46 34th floor, BNI-46 City
*                      Jl. Jend. Sudirman, Kav 1, Jakarta Pusat
*          Copyright:  (C)1998 Deru Sudibyo
*
*     Disclaimer -
*         This module is developed as a personal support, and is
*         not a part of CA support matterials.  The purpose is as
*         a temporary solution or even just a sample.  Therefor,
*         further modifications and maintenance are client's
*         responsibilities.
*
*     Modification Log -
*     +--------+------------+--------+---------------------------+
*     | Date   | Engineer   | V.R.L. | Description               |
*     +--------+------------+--------+---------------------------+
*     |98/02/12| Deru S.    | 1.0.0. | First development         |
*     |        |            |        |                           |
*     |        |            |        |                           |
*     |        |            |        |                           |
*     |        |            |        |                           |
*     |        |            |        |                           |
*     |        |            |        |                           |
*     +--------+------------+--------+---------------------------+
*
*
         EJECT ,
DERXDI   @PROLOG ESA=370,                                              +
               AMODE=31,                                               +
               RMODE=ANY,                                              +
               RENT=YES,                                               +
               BREG=R12
         SPLEVEL SET=5
*
         USING DCBE,R7            Establish DCBE structure map
         USING IHADCB,R8          Establish DCB structure map
         USING DERWTX,R9          Establish Module extension logic map
         USING WSA,R10            Establish WSA structure map
         USING SSOB,R11           Establish SSOB structure map
*
         LR    R3,R1              Keep XWTR parameter list
         LOAD  EP=DERWSA
         LR    R10,R0             Establish WSA mapping
         ST    R3,WSPARM          Save XWTR parmlist in WSA
         ST    R13,WSSVA          Save XWTR savearea in WSA
         LA    R3,L'WSCMDBUF-2    Length of cmd buffer
         STH   R3,WSSVCCIB        Save here for MGCRE
         LA    R3,WSSVCCIB
         ST    R3,WSCMDPRM+4
         MVC   WSCOUNT,=PL6'0'    Initialize counter
         WTO   'DERXDI100I XDI initialization in progress.'
*              MF=(E,LWTO)
         L     R2,=A(4*4096)
         BAS   R11,MODVSTOR       Obtain storage
         ST    R1,WSIOBUF          Save in WSA both address
         ST    R0,WSIOBUF+4         and its length
         LOAD  EP=DERXDP           Load XDP module
         STM   R0,R1,WSMODXDP      Save its address and size
         LOAD  EP=DERXDS           Load XDS module
         STM   R0,R1,WSMODXDS      Save its address and size
*        LOAD  EP=DERCOM           Load COM module
*        STM   R0,R1,WSMODCOM      Save its address and size
         LOAD  EP=DERXIO           Load XIO module
         STM   R0,R1,WSMODXIO      Save its address and size
         LOAD  EP=DERXWR           Load XWR module
         STM   R0,R1,WSMODXWR      Save its address and size
         LOAD  EP=DERWTR           Load WTR module
         STM   R0,R1,WSMODWTR      Save its address and size
         LOAD  EP=DERWTB           Load WTB module
         STM   R0,R1,WSMODWTB      Save its address and size
         LOAD  EP=DERWTG           Load WTG module
         STM   R0,R1,WSMODWTG      Save its address and size
         LOAD  EP=DERXSF           Load XSF module
         STM   R0,R1,WSMODXSF      Save its address and size
         LOAD  EP=DERDCB           Load DCB module
         STM   R0,R1,WSMODDCB      Save its address and size
         LR    R3,R0               Establish DCB map
         USING DERDCB,R3            for addressability
         CLC   =C'DERDCB ',0(R3)   Is it right ?
         BE    CONT
         WTO   'DERXDI101I XDI extension module DCB invalid, XDI start +
               up canceled.' MF=(E,LWTO)
         L     R15,=A(EXIT)
         BR    R15
CONT     EQU   *
         MVC   WSDCBDIR(WSDCBDSZ),DCB_DIR Bring DCB dir into WSA
         DROP  R3
         LOAD  EP=DERWTX           Load WTX module
         LR    R9,R0               Establish WTX map
         STM   R0,R1,WSMODWTX      Save its address and size
         CLC   =C'DERWTX ',0(R9)   Is it right ?
         BE    CONT1
         WTO   'DERXDI101I XDI extension module (WTX) invalid, XDI star+
               t up canceled.' MF=(E,LWTO)
         L     R15,=A(EXIT)
         BR    R15
CONT1    EQU   *
         LOAD  EP=DERMSG           Load MSG module
         LR    R3,R0               Establish DCB map
         USING DERMSG,R3            for addressability
         CLC   =C'DERMSG ',0(R3)   Is it right ?
         BE    CONT2
         WTO   'DERXDI101I XDI extension module MSG invalid, XDI start +
               up canceled.' MF=(E,LWTO)
         L     R15,=A(EXIT)
         BR    R15
CONT2    EQU   *
         MVC   WSMSGDIR(256),MSGDIR     Bring WTO dir into WSA
         MVC   WSMSGDIR+256(WSMSGDSZ-256),MSGDIR+256
         DROP  R3
         B     BEGIN
MODVSTOR EQU   *
         STORAGE OBTAIN,COND=NO,LENGTH=(R2),LOC=BELOW
         BR    R11
MODVSXDP DC    A(4096)
MODVSWTR DC    A(4096)
MODVSWTX DC    A(4*4096)
         EJECT ,
* ================================================================= *
*  CHECK PARAMETERS                                                 *
*                                                                   *
*  Parameters for this interface program are                        *
*     CLASSES=<1 to 8 sysout classes to be captured>                *
*                                     Required, no default          *
*     PCFORM={DISPATCH/WINDOWS}    Specify remote PC file form      *
*                                     Default is DISPATCH           *
*     DISP={DELETE/KEEP}           Specify weather flat file is     *
*                                  deleted after transferred        *
*                                     Default is DELETE             *
*     TRACE={ON/OFF}               Specify weather trace active     *
*                                     Default is OFF                *
*                                                                   *
* ================================================================= *
         SPACE ,
BEGIN    DS    0H
         @WTO  CODE=102,TRACE=ALWAYS
         MVC   WSCLASSL,=CL8' '       Make it blank
         MVC   WSFORM,=CL8' '
         MVC   WSPARMM,=CL8' '
         MVC   WSEOPARM,=A(EOF_PARMLIB)
         LR    R1,R10                 Load WSA as parameter
         NI    WSPFLAGS,X'FF'-WSPFCMND    Clear command indicator
         L     R15,WSMODXDP           Point to XDP address
         BASR  R14,R15                Call XDP
OPEN_FILES     EQU *
         L     R8,ADDR_INTRDR            Capture INTRDR DCB map
         OPEN  ((R8),(OUTPUT)),MODE=31,  Open PARMLIB and INTRDR       +
               MF=(E,LOPEN_INTRDR)
         TM    DCBOFLGS,DCBOFOPN         Is it work ?
         BZ    OPEN_ERROR
         L     R8,ADDR_PARMLIB           Capture Parmlib DCB map
         L     R7,DCBDCBE                Establish PARMLIB DCBE map
         MVC   DCBEEODA,=A(EOF_PARMLIB)  Set EOF exit routine address
         TM    DCBOFLGS,DCBOFOPN         Is it opened ?
         BO    INITCOMM                  Yes, skip NSI
         OPEN  ((R8),(INPUT)),MODE=31,   Open PARMLIB and INTRDR       +
               MF=(E,LOPEN_PARMLIB)
         TM    DCBOFLGS,DCBOFOPN         Is it work ?
OPEN_ERROR     EQU *
         @MESSAGE ERROR,OPCODE=BZ,RC=(R15),                            +
               OPER=IO,TYPE=OPEN,OBJECT=DCBDDNAM,                      +
               EXIT=EXIT
         L     R8,ADDR_INTRDR            Capture IntRDR DCB map
         TM    DCBOFLGS,DCBOFOPN         Is it work ?
         @MESSAGE ERROR,OPCODE=BZ,RC=(R15),                            +
               OPER=IO,TYPE=OPEN,OBJECT='internal reader',             +
               EXIT=EXIT
*
* Initialize OPERATOR INTERFACE
* -----------------------
INITCOMM EQU   *
         MODESET MF=(E,LMODZERO)        Set mode key 0
         @WTO  CODE=104,TRACE=ALWAYS
         EXTRACT WSCOMM,'S',            Extract communication area     +
               FIELDS=(COMM),MF=(E,LEXTRACT)
         L     R2,WSCOMM
         L     R3,0(R2)                  Comm ECB address
         ST    R3,WSECBCOM                  save it
         OI    WSECBCOM,X'80'            Mark as the last ECB list
         LA    R4,4(R2)                  Obtain origin for QEDIT
         ST    R4,WSSAVEQ                    and keep it
         ICM   R2,15,0(R4)               Is there start command ?
         BZ    INIT_COMM_STACK           If not, stack commands
         QEDIT ORIGIN=(R4),BLOCK=(R2)    Else, clear start command
INIT_COMM_STACK EQU *
         QEDIT ORIGIN=(R4),CIBCTR=255    Allow 255 command stacked
         MODESET MF=(E,LMODNZER)         Set mode key not 0
JUMPXWTR EQU   *
         @WTO  CODE=105,TRACE=ALWAYS
         L     R2,=A(32760)              Buffer size
         SLL   R2,1                      Make it double
         LA    R2,16(R2)                 Add 16
         L     R3,=A(16*1024)            16K length of record
         LA    R3,0(R3,R2)               Add 16K
         STORAGE OBTAIN,LENGTH=(R3),COND=NO,LOC=BELOW
         ST    R1,WSRCBUFA               Save it
         ST    R0,WSRCBUFA+4
         LA    R3,0(R2,R1)               Start of record area
         SRL   R3,3                      Make it
         SLL   R3,3                        doubleword boundary
         ST    R3,WSRCAREA               Save it
         ALR   R0,R1                     End of buffer
         SLR   R0,R3                     Length of record
         ST    R0,WSRCAREA+4             Save it
         LM    R2,R5,WSRCBUFA            Get BUFa, BUFl, RECa & RECl
         BUILDRCD (R2),2,(R3),(R4),(R5),MF=(E,LBLDRCD)
         LA    R12,XWTR                  Mainline address
         BR    R12                       Jump to the mainline
CHKKEYWD CLC   6(*-*,R3),2(R2)             << Executed >>
GETPARM  MVC   0(*-*,R6),0(R2)             << Executed >>
         LTORG  ,
         DROP   R12
         EJECT
*
*  +--------------------------------------------------------------+
*  |  Mainline External Processor                                 |
*  |  (1)  Initialize Xwtr enviroment i.e. establish SSOB & SSSO. |
*  |  (2)  Mainline loop to capture JES sysout occurance in its   |
*  |       capturable output queue classes.                       |
*  |  (3)  Prepare dynamic allocation/deallocation of sysout and  |
*  |       flatfile datasets within each iteration.               |
*  |  (4)  Prepare handler-routines to anticipate the result of   |
*  |       subsystem request as well as operator intervention.    |
*  +--------------------------------------------------------------+
*
         USING XWTR,R12             Mainline routine base register
         DS    0D
XWTR     EQU   *
         LA    R2,SSOBLEN1             Length of SSOB/SSSO + safeguard
         STORAGE OBTAIN,COND=NO,LENGTH=(R2)
         ST    R1,WSSSOB1              Keep it in WSA
         ST    R0,WSSSOB1+4            including its length
         STORAGE OBTAIN,COND=NO,LENGTH=(R2)
         ST    R1,WSSSOB               Keep it in WSA
         ST    R0,WSSSOB+4              including its length
         L     R1,WSSSOB               Address of SSOB pointer
         ST    R1,WSSSOBP              Save pointer
         OI    WSSSOBP,X'80'           Mark as the only ptr in the list
INITSSOB EQU   *
         L     R11,WSSSOB              Point to parmlist and
         XC    SSOBEGIN(SSOBLEN1),SSOBEGIN   Clear SSOB & SSSO
         MVC   SSOBID,=CL4'SSOB'       Put Block ID (eyecatcher)
         MVC   SSOBLEN,=AL2(SSOBHSIZ)  Specify SSOB length
         MVC   SSSOLEN,=AL2(SSSOSIZE)  Specify SSSO length
         LA    R4,SSSOBGN              Point to extension address
         ST    R4,SSOBINDV              and keep it in header
         OI    SSSOVER,SSSOCVER        Set as current version number
         MVC   SSOBFUNC,=AL2(SSOBSOUT) Select SSI SYSOUT function
         OI    SSSOFLG2,SSSOPSEE       Process sysout extension
         OI    SSSOFLG1,SSSOSCLS       CLASSes are selection criterion
         MVC   SSSOCLSL,WSCLASSL       Set CLASS list for request
         TM    WSOFLAGS,WSOFHOLD       Is held class included ?
         BZ    MAINLOOP                No, skip NSI
*>>      OI    SSSOFLG1,SSSOHLD       Yes, tell JES to select held file
MAINLOOP EQU   *
         NI    WSSFLAGS,X'FF'-WSSFOJOB Not continuation
         L     R11,WSSSOB              Point to parmlist and
         LM    R2,R3,WSDESTP1          Dest table
         CLC   =C'/*EOF ',0(R2)        Is it the last ?
         BE    TRY_NO_DEST
         MVC   SSSODEST,0(R2)          Set destination
         OI    SSSOFLG1,SSSODST        Tell SSI
         LA    R2,8(,R2)               Pop up next dest
         BCTR  R3,0
         STM   R2,R3,WSDESTP1          New position
         B     TRY_SSREQ
TRY_NO_DEST    EQU *
         XC    SSSODEST,SSSODEST       Clear dest
         NI    SSSOFLG1,X'FF'-SSSODST    Tell SSI
         MVC   WSDESTP1,WSDESTP
TRY_SSREQ EQU  *
         @WTO  CODE=106             Get parmlist address
SEND_SSREQ     EQU *
         MODESET MF=(E,LMODSUPZ)       Enter to SUPERVISOR mode key 0
         LA    R1,WSSSOBP              Point to the SSOB parmlist
         IEFSSREQ ,                    Send SUBSYSTEM REQUEST
         LR    R5,R15                  Save RC
         ST    R15,WSRCODE             Save RC
         MODESET MF=(E,LMODPRON)       Back to PROBLEM mode
         @WTO  CODE=137             Get parmlist address
         LTR   R15,R5                  Check RC
         BZ    CHECK_SSREQ             If RC = 0, continue check
         TM    WSSFLAGS,WSSFRNEW       Has it been refresed ?
         BZ    REFRESH_SSREQ           No, refresh first
         L     R15,WSRCODE             Get RC back
         @MESSAGE ERROR,OPCODE=B,RC=(R15),                             +
               OPER=SSREQ,TYPE=JES2,OBJECT='SYSOUT',                   +
               EXIT=ASK_OPER
CHECK_SSREQ    EQU *
         MVC   WSBUWRTR,SSSOPGMN       Backup writer name
         NI    WSSFLAGS,X'FF'-WSSFRNEW Turn refresh indicator off
         OI    WSOFLAGS,WSOFSSRQ        Indicate SSREQ done
         TM    WSOFLAGS,WSOFTRAC       Is trace enabled ?
         BZ    CHECK_SSREQ_RC          Keep silenc if not
         @WTO  CODE=138              Get parmlist address
*        @WTO  CODE=139              Get parmlist address
CHECK_SSREQ_RC EQU *
         L     R2,SSOBRETN            SSREQ output
         B     *+4(R2)                Do the path selection
         B     SYSOUT_FOUND           Sysout dataset found
         B     WAIT_SYSOUT            No sysout found
         B     NO_JOB_FOUND
         B     INVALID_SEARCH_ARGUMENT
         B     ERROR_VAL_16
         B     DUPLICATE_JOBNAME
         B     INVALID_JOBNAME
         B     INVALID_SSSODEST
         B     AUTHORIZATION_FAILED
         B     TOKENMAP_FAILED
         EJECT ,
*
*  +--------------------------------------------------+
*  |                                                  |
*  |  SYSOUT DETECTED                                 |
*  |    - Check whether DEST used ?                   |
*  |    - If NODEST, try to iterate all DEST          |
*  |    - Then purge if no DEST matched               |
*  |                                                  |
*  +--------------------------------------------------+
*
         SPACE ,
SYSOUT_FOUND DS 0H
         L     R11,WSSSOB              Just safeguard
         TM    WSOFLAGS,WSOFTRAC       Is trace enabled ?
         BZ    COPY_SSSO               Keep silenc
         @MESSAGE INFO,OPER=SHOW,TYPE=JOBNAME,                         +
               OBJECT=SSSOJOBN,TEXT='captured ....'
         @MESSAGE INFO,OPER=SHOW,TYPE=JOBID,                           +
               OBJECT=SSSOJOBI,TEXT='captured ....'
         @MESSAGE INFO,OPER=SHOW,TYPE=DEST,                            +
               OBJECT=SSSODEST,TEXT='captured ....'
         @MESSAGE INFO,OPER=SHOW,TYPE=WRTRNAME,                        +
               OBJECT=SSSOPGMN,TEXT='captured ....'
COPY_SSSO      EQU *
         MVC   WSSODSN,SSSODSN         Copy DSN
         MVC   WSSOWRTR,SSSOPGMN       Copy writer name
         MVC   WSSODEST,SSSODEST       Copy dest name
         MVC   WSSOMLRL,SSSOMLRL       Copy max. lrecl
         TM    SSSOFLG2,SSSODDST       Is extension info provided ?
         BZ    CHECK_WRTRNAME          No, just copy SSSO info
         CLC   =C'JESMSGLG',SSSODDND   Is it JES messages log ?
         BE    PURGE_SYSOUT            Yes, purge it
         CLC   =C'JESJCL',SSSODDND     Is it JES JCL list ?
         BE    PURGE_SYSOUT            Yes, purge it
         CLC   =C'JESYSMSG',SSSODDND   Is it JES system messages list ?
         BE    PURGE_SYSOUT            Yes, purge it
         CLC   WSSODEST,=CL8'LOCAL'  Is it LOCAL dest returned ?
         BE    PURGE_SYSOUT          Yes, test it
CHECK_WRTRNAME EQU *
         L     R15,WSMODXDS            Address of XDS
         LR    R1,R10                  Address of WSA
         BASR  R14,R15                 Call XDS
         LTR   R15,R15                 Check RC
         BNZ   SEND_SSREQ              Resend SSREQ if RC not 0
*
         TM    SSSOFLG1,SSSODST        Do we wait NODEST ?
         BNZ   SYSOUT_PROCESS          No, process
         TM    WSEFLAGS,WSEFNODS       Is it unexpected DEST
         BO    SYSOUT_CHECK            Yes, check it
SYSOUT_BACKUP  EQU *
         MVC   WSBUDSN,SSSODSN         Copy DSN
         OI    WSEFLAGS,WSEFNODS       Indicator it may be unexpected
         B     MAINLOOP                Then try again with DEST
SYSOUT_CHECK   EQU *
         CLC   WSBUDSN,SSSODSN         Is DSN the same ?
         BNE   SYSOUT_BACKUP           No, backup the info
         NI    WSEFLAGS,X'FF'-WSEFNODS Yes, clear indicator
         B     PURGE_SYSOUT            Then purge sysout
SYSOUT_PROCESS EQU *
         LA    R15,100
         CLI   WSSODEST,C' '         Is it no DEST returned ?
         BE    BAD_SYSOUT            Yes, purge it
         CLI   WSSODEST,X'00'        Is it no DEST returned ?
         BE    BAD_SYSOUT            Yes, purge it
         MVC   WSPCDRVE,WSPCHDD      Make sure use PC drive fr parm.
         L     R8,ADDR_PARMLIB       Capture Parmlib DCB map
         OC    WSSODEST,=CL8' '
         XR    R15,R15
         FIND  ((R8)),WSSODEST,D     Check if DESTid has been defined
*        ST    R15,WSRCODE             Save RC
         LTR   R15,R15               Check RC
         BZ    READ_BLOCK            Go straight if RC =  0
         @MESSAGE WARNING,OPCODE=BNZ,RC=(R15),                         +
               OPER=IO,TYPE=FIND,OBJECT=WSSODEST,                      +
               EXIT=*
         L     R15,WSRCODE           Restore RC
BAD_SYSOUT     EQU *
         TM    WSOFLAGS,WSOFTRAC       Is trace enabled ?
         BZ    PURGE_SYSOUT            Keep silenc
         @MESSAGE WARNING,OPER=FIND,RC=(R15),                          +
               TYPE=DEST,OBJECT=WSSODEST,EXIT=*
PURGE_SYSOUT   EQU *
         LA    R1,WSA                Locate WSA address
         L     R15,WSMODWTG          Locate WTG address
         BASR  R14,R15               Call WTG
         LTR   R15,R15               Check RC
         BZ    OKEY_RESULT           Go to normal path if RC = 0
         TM    WSEFLAGS,WSEFPURG     Is it unexpected sysout ?
         BO    PURGE_SYSOUT_CMD      Yes, use JES command to purge
         OI    WSEFLAGS,WSEFPURG     Remember it is unexpected
         B     MAINLOOP              Then, iterate again
*        B     ASK_OPER              Wait for sysout if RC not 0
PURGE_SYSOUT_CMD EQU *
         MVI   SSSOFLG2,SSSOCTRL   Indicate FINAL CALL to JES2
         MODESET MF=(E,LMODSUPV)   Enter to SUPERVISOR MODE
         LA    R1,WSSSOBP          POINT TO SSOB POINTER
         IEFSSREQ ,                Go to JES for give back
         MODESET MF=(E,LMODPROB)   Back to PROBLEM MODE
         MVI   WSCMDBUF,C' '
         MVC   WSCMDBUF+1(L'WSCMDBUF-1),WSCMDBUF
         MVC   WSCMDBUF+2(3),=CL3'$CJ'
         MVC   WSCMDBUF+5(4),SSSOJOBI+4     jobid
         MVC   WSCMDBUF+9(2),=C',P'
         MODESET MF=(E,LMODZERO)
         LM    R0,R1,WSCMDPRM           Get cmd parameter list
         SVC   34                       Schedule command
         MODESET MF=(E,LMODNZER)
         NI    WSEFLAGS,X'FF'-WSEFPURG  Clear indicator
         B     INITSSOB                 Then go to init SSOB
READ_BLOCK     EQU *
         @WTO  CODE=107              Get parmlist address
         L     R5,WSIOBUF         Address of I/O buffer
         READ  XDIDECB,SF,(R8),(R5),'S',MF=E
         CHECK XDIDECB
         LH    R6,DCBLRECL        Get LRECL
         LH    R7,DCBBLKSI         and BLOCK SIZE
         LA    R7,0(R7,R5)        End of full block
         L     R1,XDIDECB+16      Address of IOB
         LH    R1,14(R1)          Residual count for short block
         SR    R7,R1              Adjust block length
         SR    R7,R6              Backward to the start of last record
         LA    R2,XCPARMV         Address of variable parameters
READ_RECORD    EQU *
         CLC   =C'*/XDI ',0(R5)   Is it DXI parameter ?
         BE    CHECK_XDI          Yes, check it
         CLC   =C'*/CMD ',0(R5)   Is it COMMAND parameter ?
         BE    CHECK_CMD          Yes, check it
         CLC   =C'TYPE=',0(R5)    Is it XCOM TYPE parameter ?
         BE    READ_NEXT          Yes, ignore it
         CLC   =C'FILETYPE=',0(R5) Is it XCOM FILETYPE parameter ?
         BE    READ_NEXT          Yes, ignore it
         CLC   =C'FILE=',0(R5)    Is it XCOM FILE parameter ?
         BE    READ_NEXT          Yes, ignore it
         CLC   =C'LFILE=',0(R5)   Is it XCOM LFILE parameter ?
         BE    READ_NEXT          Yes, ignore it
         CLC   =C'LU=',0(R5)      Is it XCOM LU parameter ?
         BE    CHANGE_LU          Yes, process it
         CLC   =C'LIST=',0(R5)    Is it XCOM LIST parameter ?
         BE    CHANGE_LIST        Yes, process it
         CLC   =C'/* ',0(R2)       Is no more space ?
         BE    EOF_PARM           Yes, force EOF member
         MVC   0(80,R2),0(R5)     Get in the parameter
         LA    R2,80(,R2)         Next vcard
READ_NEXT      EQU *
         BXLE  R5,R6,READ_RECORD  Search next record in block
         B     READ_BLOCK         Iterate to read next block
CHANGE_LU      EQU *
*        MVI   XCGROUP,C' '       Put blank
*        MVI   XCGROUP+1(79),XCGROUP and roll it to clear data
CHANGE_LIST    EQU *
         MVC   XCGROUP,0(R5)      Replace the parameter
         B     READ_NEXT          Iterate
CHECK_XDI EQU  *
         CLC   =C'PCDRIVE=',6(R5)       Is "*/XDI PCDRIVE=.." appear ?
         BE    OVER_PCDRIVE             Yes, handle it
         CLC   =C'XDISP=KEEP',6(R5)     Is "*/XDI XDISP=KE.." appear ?
         BE    OVER_XDISP_KEEP          Yes, handle it
         CLC   =C'XDISP=DELETE',6(R5)   Is "*/XDI XDISP=DE.." appear ?
         BE    OVER_XDISP_DELETE        Yes, handle it
         CLC   =C'FORM=DISPATCH',6(R5)  Is "*/XDI FORM=DIS.." appear ?
         BE    OVER_FORM_DSP            Yes, handle it
         CLC   =C'FORM=WINDOWS ',6(R5)  Is "*/XDI FORM=WIN.." appear ?
         BE    OVER_FORM_WIN            Yes, handle it
         CLC   =C'FORM=S/390 ',6(R5)    Is "*/XDI FORM=S/3.." appear ?
         BE    OVER_FORM_S390           Yes, handle it
         CLC   =C'FORM=S390 ',6(R5)     Is "*/XDI FORM=S39.." appear ?
         BE    OVER_FORM_S390           Yes, handle it
         @WTO  CODE=108
         B     READ_NEXT                Iterate
OVER_PCDRIVE   EQU *
         MVC   WSOVHDD,14(R5)
         MVC   WSPCDRVE,WSOVHDD
         B     OVERRIDE_OKEY
OVER_XDISP_KEEP EQU *
         OI    WSOVFLGS,WSOFXKEP      Indicate XDISP=KEEP
         B     OVERRIDE_OKEY
OVER_XDISP_DELETE EQU *
         NI    WSOVFLGS,X'FF'-WSOFXKEP  Indicate XDISP=DELETE
         B     OVERRIDE_OKEY
OVER_FORM_DSP  EQU *
         MVI   WSOVFORM,WSFFDISP      Indicate override form DISPATCH
         B     OVERRIDE_OKEY
OVER_FORM_WIN  EQU *
         MVI   WSOVFORM,WSFFWIND      Indicate override form Windows
         B     OVERRIDE_OKEY
OVER_FORM_S390 EQU *
         MVI   WSOVFORM,WSFFS390      Indicate override form S/390
OVERRIDE_OKEY  EQU *
         OI    WSPFLAGS,WSPFOVER      Indicate overridden status
         @WTO  CODE=109              Get parmlist address
         B     READ_NEXT              Iterate
CHECK_CMD EQU  *
         MVI   WSCMDBUF,C' '
         MVC   WSCMDBUF+1(L'WSCMDBUF-1),WSCMDBUF
         MVC   WSCMDBUF(65),6(R5)     Move command into buffer
         MODESET MF=(E,LMODZERO)      Set auth key 0
         LM    R0,R1,WSCMDPRM         Access command parmlist
         SVC   34                     Schedule command
         MODESET MF=(E,LMODNZER)      Release auth key 0
         @WTO  CODE=110              Get parmlist address
         B     READ_NEXT              Iterate
EOF_PARMLIB    EQU *
         CLC   =C'/*EOF ',0(R2)      Is no more space ?
         BE    EOF_PARM              Yes, force EOF member
         MVC   0(8,R2),=CL8'/*EOF'
EOF_PARM       EQU *
         @WTO  CODE=111              Get parmlist address
CALL_XIO EQU   *
         LA    R1,WSA                Locate WSA address
         TM    WSSFLAGS,WSSFSFIL     Is it SF (send file) request ?
         BO    CALL_XSF              Yes, handle it
         L     R15,WSMODXIO          Locate WTR address
         BASR  R14,R15               Call WTR
         ST    R15,WSRCODE           Save RC
         NI    WSPFLAGS,X'FF'-WSPFOVER Clear override flag
CALL_DONE      EQU *
         @WTO  CODE=112              Get parmlist address
         L     R15,WSRCODE           Restore RC
         LTR   R15,R15               Is it OK
         BNZ   PURGE_SYSOUT          If not OK, purge sysout
OKEY_RESULT    EQU *
         OI    WSSFLAGS,WSSFOJOB     Indicate to continue this job
         B     SEND_SSREQ            Iterate retrieve the same job
CALL_XSF EQU   *
         L     R15,WSMODXSF          EP address of DERWTR
         BASR  R14,R15               Call WTR
         NI    WSSFLAGS,X'FF'-WSSFSFIL  Clear flag bit
         B     CALL_DONE
         EJECT ,
*
*  +-----------------------------------------------------------+
*  |                                                           |
*  |    NO SYSOUT FOUND                                        |
*  |        - Check whether NODEST                             |
*  |        - If NODEST, then continue sleep                   |
*  |        - Else, iterate all DESTs                          |
*  |                                                           |
*  +-----------------------------------------------------------+
*
         SPACE ,
WAIT_SYSOUT    EQU *
         TM    WSSFLAGS,WSSFOJOB       Is it continunation ?
         BO    MAINLOOP                Yes, iterate
         TM    SSSOFLG1,SSSODST        Do we wait any dest ?
         BNZ   REFRESH_SSREQ           Yes, need to be refreshed
WAIT     EQU   *
         L     R11,WSSSOB              Just safeguard
         TM    WSOFLAGS,WSOFSSRQ       Is SSREQ done ?
         BZ    WAIT_ERROR
         @WTO  CODE=113,TRACE=ALWAYS
         MODESET MF=(E,LMODSUPZ)       Enter to SUPERVISOR mode
         L     R2,SSSOWTRC             Point to JES/WTR comm. area
         ST    R2,WSECBJES             Keep it in the list
         WAIT  ECBLIST=WSECBLST,LONG=YES Wait for JES and Console
         MODESET MF=(E,LMODPRON)       Enter to PROBLEM mode
         L     R2,WSECBCOM             Access command ECB
         CLI   0(R2),X'00'             Is CMD posted ?
         BE    MAINLOOP                No, just skip
         OI    WSOFLAGS,WSOFCOMM       Yes, remember it
         B     OPER_COMMAND            and handle the command
WAIT_ERROR     EQU *
         @WTO  CODE=140,TRACE=ALWAYS
         B     ASK_OPER
         EJECT ,
*
*  +--------------------------------------------------+
*  |                                                  |
*  |  Other Unexpected Event                          |
*  |    - Review the problem                          |
*  |    - Send message and                            |
*  |    - Issue WTOR to let operator decide           |
*  |                                                  |
*  +--------------------------------------------------+
*
         SPACE ,
         SPACE ,
NO_JOB_FOUND EQU *
         @WTO  CODE=114,TRACE=ALWAYS  Get parmlist address
         B     ASK_FOR_NEXT_STEP
INVALID_SEARCH_ARGUMENT EQU *
         @WTO  CODE=115,TRACE=ALWAYS  Get parmlist address
         B     ASK_FOR_NEXT_STEP
ERROR_VAL_16 EQU *
         @WTO  CODE=116,TRACE=ALWAYS  Get parmlist address
         B     ASK_FOR_NEXT_STEP
DUPLICATE_JOBNAME EQU *
         @WTO  CODE=117,TRACE=ALWAYS  Get parmlist address
         B     ASK_FOR_NEXT_STEP
INVALID_JOBNAME EQU *
         @WTO  CODE=118,TRACE=ALWAYS  Get parmlist address
         B     ASK_FOR_NEXT_STEP
INVALID_SSSODEST EQU *
         @WTO  CODE=119,TRACE=ALWAYS  Get parmlist address
         B     ASK_FOR_NEXT_STEP
         B     BAD_SYSOUT
AUTHORIZATION_FAILED EQU *
         @WTO  CODE=120,TRACE=ALWAYS  Get parmlist address
         B     ASK_FOR_NEXT_STEP
TOKENMAP_FAILED EQU *
         @WTO  CODE=121,TRACE=ALWAYS  Get parmlist address
ASK_FOR_NEXT_STEP EQU *
         XC    WSECB,WSECB         Clear ECB
ASK_OPER EQU    *
         TM    WSSFLAGS,WSSFWAIT   Must we wait ?
         BO    WAIT_OPER           Yes, go wait
         L     R3,WSMSG122              Get parmlist address
         LA    R2,WSCOMBUF+2
         MVC   WSCOMBUF(2),=AL2(64)
         WTOR  'DERXDI122R Enter ''W'' to WAIT, ''R'' to RETRY or anyth+
               ing else to EXIT',(R2),64,WSECB,MF=(E,(R3))
         WAIT  ECB=WSECB           Wait for reply
         XC    WSECB,WSECB         Clear ECB
         MVC   WSREPLY,WSCOMBUF+2
         OI    WSREPLY,C' '        Force REPLY to uppercase
         CLI   WSREPLY,C'W'        Should we WAIT?
         BE    ASK_WAIT            Yes, go wait
         CLI   WSREPLY,C'R'        Should we RETRY?
         BE    REFRESH_SSREQ       Yes, go retry
         CLI   WSREPLY,C'S'        Is it command ?
         BE    REPLY_COMM          Yes, handle it
         L     R12,=A(EXIT)        Address of Exit procedure
         BR    R12                 Go to exit
*
ASK_WAIT EQU   *
         @WTO  CODE=142,TRACE=ALWAYS
         OI    WSSFLAGS,WSSFWAIT   Indicate we must wait
         B     WAIT_SYSOUT         Go to wait
*
*   +--------------------------------------------+
*   |   Refresh SSI Request                      |
*   |    -  Disconnect SSI                       |
*   |                                            |
*   +--------------------------------------------+
*
REFRESH_SSREQ  EQU *
         L     R11,WSSSOB          Just make sure SSOB established
         MVI   SSSOFLG2,SSSOCTRL   Indicate FINAL CALL to JES2
         MODESET MF=(E,LMODSUPV)   Enter to SUPERVISOR MODE
         LA    R1,WSSSOBP          POINT TO SSOB POINTER
         IEFSSREQ ,                Go to JES for give back
         MODESET MF=(E,LMODPROB)   Back to PROBLEM MODE
         OI    WSSFLAGS,WSSFRNEW   Indicate it has been refreshed
REGRESS_DEST   EQU *
         LM    R2,R3,WSDESTP1      DEST current stack pointer
         LTR   R3,R3               Is it the last DEST entry ?
         BZ    REWIND_DEST         Yes, rewind it
         C     R2,WSDESTP          Is it the first DEST entry ?
         BL    REWIND_DEST         No, rewind it
         SLL   R3,3                Multiply 8
         LA    R2,0(R3,R2)         Search last entry
         XR    R3,R3               Set counter 0
         B     INITSSOB            Than reinitialize SSOB
*
REWIND_DEST    EQU *
         LA    R3,1(,R3)           Add 1 to counter
         ST    R3,WSDESTP1+4       Save stack number
         LA    R3,8                Length of stack entry
         SLR   R2,R3               Rewind one entry
         ST    R2,WSDESTP1         and update stack position
         B     INITSSOB            Reinitialize SSOB
*
REPLY_COMM     EQU *
         MVI   WSWORK,C' '
         MVC   WSWORK+1(63),WSWORK
         OC    WSCOMBUF+2(64),WSWORK
         B     CMD_CHECK
*
WAIT_OPER      EQU *
        WAIT   ECBLIST=WSECBCOM           Wait OPER command
*
*  +---------------------------------------------+
*  |                                             |
*  |  Console Communication Handler              |
*  |                                             |
*  |                                             |
*  +---------------------------------------------+
*
*
OPER_COMMAND   EQU *
         USING CIB,R5                     Map of CIB
         L     R4,WSSAVEQ                 Access QEDIT base
         L     R5,0(R4)                   Seek CIB address
         CLI   CIBVERB,CIBSTOP            Is it STOP command
         BE    CMD_STOP                   Handle it if so
         CLI   CIBVERB,CIBMODFY           Is it MODIFY command
         BE    CMD_MODIFY                 Handle it if so
         QEDIT ORIGIN=(R4),BLOCK=(R5)     Free CIB
         @WTO  CODE=123                   Get parmlist address
         B     MAINLOOP
CMD_STOP EQU   *
         @WTO  CODE=124,TRACE=ALWAYS      Get parmlist address
         B     EXIT                       Exit
CMD_MODIFY     EQU *
         MVI   WSCOMBUF,C' '
         MVC   WSCOMBUF+1(L'WSCOMBUF-1),WSCOMBUF
         XR    R3,R3                      Clear GR 2
         IC    R3,CIBDSIZE+1              Size of command text
         STH   R3,WSCOMBUF                Store in our buffer
         BCTR  R3,0                       Reduce 1 for EX
         EX    R3,COPY_CMD
         QEDIT ORIGIN=(R4),BLOCK=(R5)     Free CIB
CMD_CHECK      EQU *
         CLC   =C'SS,',WSCOMBUF+2         Is it SEND_SPOOL command ?
         BE    SEND_SPOOL                 Yes, handle it
         CLC   =C'SF,',WSCOMBUF+2         Is it SEND_FILE command ?
         BE    SEND_FILE
         CLC   =C'RETRY',WSCOMBUF+2       Is it RETRY command ?
         BE    CMD_RETRY                  Yes, handle it
         CLC   =C'REFRESH',WSCOMBUF+2     Is it RETRY command ?
         BE    CMD_REFRESH                Yes, handle it
         CLC   =C'SHUTDOWN',WSCOMBUF+2    Is it RETRY command ?
         BE    CMD_STOP                   Yes, handle it
         LA    R2,WSCOMBUF                Address of command buffer
         ST    R2,WSCOMPRM                Put in plist style
         OI    WSCOMPRM,X'80'             Mark as last parm address
         OI    WSPFLAGS,WSPFCMND          Indicate command
         LR    R1,R10                     Address of WSA
         L     R15,WSMODXDP               Address of XDP module
         BASR  R14,R15                    Call XDP
         NI    WSPFLAGS,X'FF'-WSPFCMND    Clear command indicator
         B     REFRESH_SSREQ              Then refresh SSREQ
CMD_RETRY      EQU *
         @WTO  CODE=174,TRACE=ALWAYS
         NI    WSSFLAGS,X'FF'-WSSFWAIT    Remove wait bit
         B     MAINLOOP
CMD_REFRESH    EQU *
         @WTO  CODE=175,TRACE=ALWAYS
         B     REFRESH_SSREQ
COPY_CMD OC    WSCOMBUF+2(*-*),CIBDATA    << Executed >>
         EJECT
*
*  +--------------------------------------------------------------+
*  |  Interactive SEND SPOOL Command Handler                      |
*  |    F XDI,SS,Destid,Rptname,Datasetname                       |
*  |                                                              |
*  |    (1)  Update DSN in ARB99 for JES sysout dynamic (SVC 99)  |
*  |         allocation                                           |
*  |    (2)  Update DSN in FRB99 for flat dataset allocation      |
*  |    (3)  Call DERXSS                                          |
*  |                                                              |
*  +--------------------------------------------------------------+
*
         SPACE ,
SEND_FILE      EQU *
         OI    WSSFLAGS,WSSFSFIL     Remember to send file
SEND_SPOOL     EQU *
         MVC   WSSODEST,=CL8' '     Clear dest
         LA    R2,WSCOMBUF+5
         LA    R1,WSSODEST           Target
         LA    R15,L'WSSODEST        Length of target
SS_DEST  EQU   *
         CLI   0(R2),C' '            Is it end of argument ?
         BE    SS_ABORT              Yes, check report id
         CLI   0(R2),C','            Is it argument delimiter ?
         BE    SS_DEST_OK            Yes, check report id
         MVC   0(1,R1),0(R2)         Copy 1 byte
         LA    R2,1(,R2)             Search next byte source
         LA    R1,1(,R1)             Search next byte target
         BCT   R3,SS_DEST_BCT        Reduce total length
         B     SS_ABORT              Abort because incomplete
SS_DEST_BCT    EQU *
         BCT   R15,SS_DEST           Iterate
         B     SS_ABORT              Abort because incomplete
SS_DEST_OK     EQU *
         LA    R2,1(,R2)             Search next byte source
         MVC   WSSOWRTR,=CL8' '     Clear WRTR
         LA    R1,WSSOWRTR           It is a target
         LA    R15,L'WSSOWRTR        Length of target
SS_RPT   EQU *
         CLI   0(R2),C' '            Is it end of argument ?
         BE    SS_ABORT              Yes, check report id
         CLI   0(R2),C','            Is it argument delimiter ?
         BE    SS_RPT_OK             Yes, check report id
         MVC   0(1,R1),0(R2)         Copy 1 byte
         LA    R2,1(,R2)             Search next byte source
         LA    R1,1(,R1)             Search next byte target
         BCT   R3,SS_RPT_BCT         Reduce total length
         B     SS_ABORT              Abort because incomplete
SS_RPT_BCT     EQU *
         BCT   R15,SS_RPT            Iterate
         B     SS_ABORT              Abort because incomplete
SS_RPT_OK      EQU *
         LA    R2,1(,R2)             Search next byte source
         BCT   R3,SS_DSN_CLR         Reduce total length
         B     SS_ABORT              Abort because incomplete
SS_DSN_CLR     EQU *
         MVI   WSSODSN,C' '         Clear WRTR
         MVC   WSSODSN+1(L'WSSODSN-1),WSSODSN
         LA    R1,WSSODSN            It is a target
         LA    R15,L'WSSODSN         Length of target
SS_DSN   EQU *
         CLI   0(R2),C' '            Is it end of argument ?
         BE    SS_DSN_OK             Yes, check report id
         CLI   0(R2),C','            Is it argument delimiter ?
         BE    SS_DSN_OK             Yes, check report id
         MVC   0(1,R1),0(R2)         Copy 1 byte
         LA    R2,1(,R2)             Search next byte source
         LA    R1,1(,R1)             Search next byte target
         BCT   R3,SS_DSN_BCT         Reduce total length
         B     SS_DSN_OK             Abort because incomplete
SS_DSN_BCT     EQU *
         BCT   R15,SS_DSN            Iterate
SS_DSN_OK      EQU *
         MVC   WSSOMLRL,=AL2(137)    Guess lrecl is 137
         B     SYSOUT_PROCESS
SS_ABORT EQU   *
         @WTO  CODE=141
         B     MAINLOOP              Global iteration
         LTORG ,
         DROP  R12
         EJECT
*
*  +--------------------------------------------------------------+
*  |  Exit procedure                                              |
*  |    (1)  Tell JES that interaction is finished.               |
*  |    (2)  Free SSOB/SSSO storage area.                         |
*  |    (3)  Restore system savearea address                      |
*  |    (4)  Disconnect DERWTR and DERWTX                         |
*  |    (5)  Free WSA                                             |
*  |    (6)  Restore states                                       |
*  |    (7)  Return to MVS                                        |
*  |                                                              |
*  +--------------------------------------------------------------+
*
         DS    0H
EXIT     EQU   *
         BASR  R12,0
         USING *,R12
         @WTO  CODE=125,TRACE=ALWAYS
         L     R8,ADDR_PARMLIB      Capture PARMLIB DCB
         TM    DCBOFLGS,DCBOFOPN    Is it open ?
         BZ    EXIT01               No, just leave it
         CLOSE ((R8)),MODE=31,MF=(E,LCLOSE) Close PARMLIB
         @WTO  CODE=126,TRACE=ALWAYS
EXIT01   EQU   *
         L     R8,ADDR_INTRDR       Map INTRDR DCB
         TM    DCBOFLGS,DCBOFOPN    Is it open ?
         BZ    EXIT02               No, just leave it
         CLOSE ((R8)),MODE=31,MF=(E,LCLOSE)   Close INTRDR
         @WTO  CODE=127,TRACE=ALWAYS
EXIT02   EQU   *
*>>      TM    WSOFLAGS,WSOFSSRQ   Has SSRQ processed ?
*>>      BZ    EXIT03              No, just skip
         MVI   SSSOFLG2,SSSOCTRL   Indicate FINAL CALL to JES2
         MODESET MF=(E,LMODSUPV)   Enter to SUPERVISOR MODE
         LA    R1,WSSSOBP          POINT TO SSOB POINTER
         IEFSSREQ ,                Go to JES for give back
         MODESET MF=(E,LMODPROB)   Back to PROBLEM MODE
EXIT03   EQU   *
         @WTO  CODE=128,TRACE=ALWAYS
         LM    R2,R3,WSSSOB
*        STORAGE RELEASE,COND=YES, Free SSOB/SSSO                      +
               ADDR=(R2),LENGTH=(R3)    HERE'S WHERE IT LIVES
         LM    R2,R3,WSIOBUF
*        STORAGE RELEASE,COND=YES, Free I/O buffer                     +
               ADDR=(R2),LENGTH=(R3)    HERE'S WHERE IT LIVES
         @WTO  CODE=129,TRACE=ALWAYS
         DELETE EP=DERCOM          Release DERCOM
         DELETE EP=DERXIO          Release DERXIO
         DELETE EP=DERWTR          Release DERWTR
         DELETE EP=DERXSF          Release DERXSF
         DELETE EP=DERXDP          Release DERXDP
         DELETE EP=DERWTX          Release DERWTX
*        DELETE EP=DERDCB          Release DERDCB
         DELETE EP=DERMSG          Release DERMSG
*        L     R13,WSSVA           Restore savearea
         @EXIT
         LTORG ,
         EJECT
*
* +--------------------------------+
* | Working Storage Area Map       |
* | Used as working set and other  |
* | dynamic storages directory     |
* +--------------------------------+
*
         DERWSA
         EJECT ,
*
* +--------------------------------+
* | WTX Module Extension Area Map  |
* | Used as a common non reentrant |
* | part of this module            |
* +--------------------------------+
*
         DERWTX TYPE=DSECT
         EJECT ,
*
* +--------------------------------+
* | Module Extension Area Map      |
* | Used as a DCB definitions set  |
* | in nonreentrant part of module |
* +--------------------------------+
*
         DERDCB TYPE=DSECT,RMODE=24,AMODE=31
         EJECT ,
*
* +--------------------------------+
* | Module Extension Area Map      |
* | Used as a MSG definitions set  |
* | in nonreentrant part of module |
* +--------------------------------+
*
         DERMSG TYPE=DSECT
*
* +--------------------------------+
* | Command interaction buffer     |
* | used to interfacing operator   |
* | console transaction            |
* +--------------------------------+
*
         DERCIB TYPE=DSECT
*        @EPILOG
*
*   STANDARD MVS SOURCE COPY
*   FOR DSECTS AND EQUATES
*   ------------------------
*
         CVT   DSECT=YES
         IEFJESCT TYPE=DSECT,MNTBL=YES
         DCBD  DSORG=(PO,PS)
         IHADCBE
         IEFZB4D0
         EJECT ,
*
*   +----------------------------------------+
*   |  SSOB                                  |
*   |      SSOB-header/                      |
*   |                / SSSO                  |
*   |                                        |
*   +----------------------------------------+
*
         PRINT NOGEN
         IEFSSOBH
         ORG   ,
SSOBGN   EQU   *
         IEFSSSO SOEXT=YES
SSSO_END EQU   *
         IEFJSSIB
*        IEFJSSOB SO,CONTIG=YES
*        IEFJSSOB (SO,AG,AL),CONTIG=YES
         END   DERXDI
./ ADD NAME=DERXDP   0100-01324-01324-1743-00839-00839-00000-DERU-S
**********************************************************************
*
*                     +---------+
*     Module Name  -  | DERXDP  |
*                     +---------+
*                     CA-Dispatch -to- CA-XCOM Handshaking Interface
*
*     Function -
*            Evaluate parameter entered to XDI at the startup time
*            or during operating time via MODIFY command.
*
*     Operating Environment -
*        Type              MVS System Program
*        Min. Auth.        Problem state
*        Dsp.unit mode     Task
*        AMODE             24-bit or 31-bit
*        XM                PASN=HASN=SASN
*        ASC mode          Primary
*        Interrupt status  Enabled for I/O and Ext. interrupts
*        Locks             No locks held
*        Control Parm      The SSOB and SSSO control blocks can
*                          reside in storage above 16 megabytes.
*        Recovery          Program should provide an ESTAE-type
*                          recovery environment. See MVS/ESA SP V5
*                          Auth Assembler Services Guide for more info
*                          an ESTAE-type recovery environment.
*
*
*     Syntax -
*
*
*     Operation -
*           Called by DERXDI via LOAD and BASR
*
*     Register Usage -
*          R0-R1   -->  System interface
*          R2-R7   -->  Work registers
*          R8      -->  DCB map (IHADCB) address
*          R9      -->  Module extension base address
*          R10     -->  WSA (working storage area) address
*          R11     -->  Main module base address
*          R12     -->  Main module base address
*          R13     -->  Conventional savearea
*          R14     -->  BAS or BASR return address
*          R15     -->  Return code
*
*     Author -
*          Name     :  Deru Sudibyo
*                      Technical Consultant
*                      Computer Associates
*                      Indonesia Office
*                      Wisma BNI-46 34th floor, BNI-46 City
*                      Jl. Jend. Sudirman, Kav 1, Jakarta Pusat
*          Copyright:  (C)1998 Deru Sudibyo
*
*     Disclaimer -
*         This module is developed as a personal support, and is
*         not a part of CA support matterials.  The purpose is as
*         a temporary solution or even just a sample.  Therefor,
*         further modifications and maintenance are client's
*         responsibilities.
*
*     Modification Log -
*     +--------+------------+--------+---------------------------+
*     | Date   | Engineer   | V.R.L. | Description               |
*     +--------+------------+--------+---------------------------+
*     |98/02/12| Deru S.    | 1.0.0. | First development         |
*     |        |            |        |                           |
*     |        |            |        |                           |
*     |        |            |        |                           |
*     |        |            |        |                           |
*     |        |            |        |                           |
*     |        |            |        |                           |
*     +--------+------------+--------+---------------------------+
*
*
         EJECT ,
DERXDP   @PROLOG ESA=390,                                              +
               AMODE=31,                                               +
               RMODE=ANY,                                              +
               RENT=YES,                                               +
               BREG=(R11,R12)
*
         USING DCBE,R7            Establish DCBE structure map
         USING IHADCB,R8          Establish DCB structure map
         USING DERWTX,R9          Establish Module extension logic map
         USING WSA,R10            Establish WSA structure map
*
*        LR    R10,R1             Enable WSA map
*        L     R9,WSMODWTX        Enable WTX map
*
         LOAD  EP=DERWSA
         LR    R10,R0             Establish WSA addressability
         LOAD  EP=DERWTX
         LR    R9,R0              Establish WTX addressability
         EJECT ,
* ================================================================= *
*  CHECK PARAMETERS                                                 *
*                                                                   *
*  Parameters for this interface program are                        *
*     CLASSES=<1 to 8 sysout classes to be captured>                *
*                                     Required, no default          *
*     PCFORM={DISPATCH/WINDOWS}    Specify remote PC file form      *
*                                     Default is DISPATCH           *
*     DISP={DELETE/KEEP}           Specify weather flat file is     *
*                                  deleted after transferred        *
*                                     Default is DELETE             *
*     TRACE={ON/OFF}               Specify weather trace active     *
*                                     Default is OFF                *
*                                                                   *
* ================================================================= *
         SPACE ,
         @WTO  CODE=103,TRACE=ALWAYS
         TM    WSPFLAGS,WSPFCMND      Is it called to process cmd ?
         BO    CMD_PROCESS            Ya, take arguments
         L     R1,WSPARM              Access parameter list address
         L     R2,0(,R1)              Access 1st parameter address
         B     BEGIN
CMD_PROCESS    EQU *
         LA    R2,WSCOMBUF            Command buffer
         WTO   TEXT=(R2),MF=(E,LWTO)
         LA    R1,WSCOMPRM            Address of parameter
BEGIN    EQU   *
         CLC   =C'LIST ',2(R2)        Is it LIST request ?
         BE    SHOWPARM               Yes, show parameter
         CLC   =C'L ',2(R2)           Is it L request ?
         BE    SHOWPARM               Yes, same effect - show parameter
         NI    WSPFLAGS,X'FF'-WSPFFILE Turn indicator off
         CLC   =C'TABLE=',2(R2)       Is TABLE=mm specified ?
         BE    DEST_TABLE             No, skip NSI
         CLC   =C'FILE=',2(R2)        Is FILE=mm specified ?
         BNE   CHKPARM                No, skip NSI
PARM_FILE EQU  *
         MVC   WSPARMM(6),=CL6'XDISYS'      Set basic member name
         MVC   WSPARMM+6(2),7(R2)        Put suffix
         BAS   R14,OPEN_PARM          Yes, open parmlib
         OI    WSPFLAGS,WSPFFILE      Turn indicator on
         MVC   WSIOREC,WSIOBUF        Access 1st record of block
PARM_REC EQU   *
         L     R2,WSIOREC             Access a record of block
PARM_REC_CHECK EQU *
         C     R2,WSIOREC+4           Overlimit ?
         BH    PARMNEXT               Go out if so
         CLI   0(R2),C' '             Empty record ?
         BE    PARM_REC_NEXT          Seek next record if so
         CLI   0(R2),C'*'             Commented record ?
         BNE   PARM_REC_CONT          Begin to check record if not
PARM_REC_NEXT  EQU *
         LA    R2,80(,R2)
         B     PARM_REC_CHECK         Iterate
PARM_REC_CONT  EQU *
         LR    R3,R2                  Address of record
         LA    R7,72                  Max parm length is 72
PARM_REC_LOOP  EQU *
         CLI   0(R3),C' '             End of parm ?
         BE    PARM_REC_END           Yes, leave loop
         LA    R3,1(,R3)              Seek next byte
         BCT   R7,PARM_REC_LOOP       Iterate
PARM_REC_END   EQU *
         MVC   WSCARD+2(72),0(R2)       Bring parm record as well
         LA    R2,80(,R2)             Next record address
         ST    R2,WSIOREC             and save here
         LA    R2,WSCARD              Address of card
         LA    R7,72
         STH   R7,WSCARD
         LA    R2,WSCARD
         WTO   TEXT=(R2),MF=(E,LWTO)
         LA    R2,WSCARD+2            Address of parameter
         B     CHKPARM1               Skip NSI
DESTTAB  EQU   *
         MVC   WSTABLE(6),=C'XDITAB'
         MVC   WSTABLE+6(2),0(R2)
         OI    WSPFLAGS,WSPFTABL      Indicate table will be renew
         B     UPDATE_TABLE
CHKPARM  EQU   *
         L     R2,0(,R1)              Access 1st parameter address
         XR    R7,R7                  Clear R7
         ICM   R7,B'0011',0(R2)       Parameter length
         LA    R2,2(,R2)              Straight to parm area
CHKPARM1 EQU   *
         LA    R3,PARMKEYS            Point to parm table
         LA    R4,PARMKEYN            Number of entries
         XR    R5,R5                  Zap GR 5
PARMLOOP EQU   *
         IC    R5,3(R3)               Get keyword string length
         EX    R5,CHKKEYWD            Is it the right keyword ?
         BE    PARMOKEY               Yes, handle it
         LA    R3,PARMKEYW(R3)        Seek next entry
         BCT   R4,PARMLOOP            and iterate
*        @MESSAGE ERROR,OPCODE=B,OBJECT=(R2),TYPE=PARM,                +
               RC=*,EXIT=PARMNEXT
         B     PARMNEXT               Get next parm
PARMKEYS DS    0H
   DC Y(CHKCLS-PARMKEYS),AL1(*-*,7,8,0),CL8'CLASSES='
   DC Y(CHKCLS-PARMKEYS),AL1(*-*,5,6,0),CL8'CLASS=  '
   DC Y(CHKRQC-PARMKEYS),AL1(*-*,7,8,0),CL8'RQCLASS='
   DC Y(CHKFRM-PARMKEYS),AL1(*-*,6,7,0),CL8'PCFORM= '
   DC Y(CHKTRC-PARMKEYS),AL1(*-*,5,6,0),CL8'TRACE=  '
   DC Y(CHKDSP-PARMKEYS),AL1(*-*,4,5,0),CL8'DISP=   '
   DC Y(CHKXDS-PARMKEYS),AL1(*-*,5,6,0),CL8'XDISP=  '
   DC Y(CHKHLD-PARMKEYS),AL1(*-*,4,5,0),CL8'HOLD=   '
   DC Y(CHKTAB-PARMKEYS),AL1(*-*,7,8,0),CL8'DESTTAB='
   DC Y(CHKTAB-PARMKEYS),AL1(*-*,5,6,0),CL8'TABLE=  '
   DC Y(CHKXCP-PARMKEYS),AL1(*-*,5,6,0),CL8'XPARM=  '
   DC Y(CHKHDD-PARMKEYS),AL1(*-*,7,8,0),CL8'PCDRIVE='
   DC Y(CHKSLB-PARMKEYS),AL1(*-*,7,8,0),CL8'STEPLIB='
   DC Y(CHKCLB-PARMKEYS),AL1(*-*,6,7,0),CL8'CAILIB= '
   DC Y(CHKGLB-PARMKEYS),AL1(*-*,7,8,0),CL8'GLOBLIB='
   DC Y(CHKRLB-PARMKEYS),AL1(*-*,7,8,0),CL8'RESTLIB='
   DC Y(CHKXLB-PARMKEYS),AL1(*-*,7,8,0),CL8'CNTLLIB='
   DC Y(CHKXLB-PARMKEYS),AL1(*-*,7,8,0),CL8'PARMLIB='
   DC Y(CHKLRL-PARMKEYS),AL1(*-*,5,6,0),CL8'LRECL=  '
PARMKLEN EQU   *-PARMKEYS
PARMKEYW EQU   14
PARMKEYN EQU   PARMKLEN/PARMKEYW
         SPACE ,
CHKKEYWD CLC   6(*-*,R3),0(R2)             << Executed >>
GETPARM  MVC   0(*-*,R6),0(R2)             << Executed >>
         SPACE ,
PARMOKEY EQU   *
         LA    R2,1(R5,R2)            Jump over the keyword
         LR    R4,R7                  Copy parm length
         SR    R4,R5                  Reduced by kwd length
         LR    R7,R4                  Copy to GR 7
         BCTR  R4,0                   Reduced again by 1
         IC    R5,4(R3)               Get parm string length
         LH    R6,0(,R3)              Get relocation factor
         B     PARMKEYS(R6)           Relocate and go
*
*   +---------------------------------------------------+
*   |                                                   |
*   |   Check Library Parameter                         |
*   |     Get list of 1 to 44 byte STEPLIB parameter    |
*   |                                                   |
*   +---------------------------------------------------+
*
CHKSLB   EQU   *
         LA    R15,WSSTPLIB
         LA    R6,WSSTPLIB
         B     CHKLIB
CHKCLB   EQU   *
         LA    R15,WSCAILIB
         LA    R6,WSCAILIB
         B     CHKLIB
CHKGLB   EQU   *
         LA    R15,WSGLBLIB
         LA    R6,WSGLBLIB
         B     CHKLIB
CHKRLB   EQU   *
         LA    R15,WSRSTLIB
         LA    R6,WSRSTLIB
         B     CHKLIB
CHKXLB   EQU   *
         LA    R15,WSCTLLIB
         LA    R6,WSCTLLIB
         B     CHKLIB
CHKLIB   EQU   *
         MVI   0(R15),C' '
         MVC   1(43,R15),0(R15)
         BAS   R14,COPYPARM           Perform copy parameter
         B     PARMNEXT               Get next parm
*
*   +---------------------------------------------------+
*   |                                                   |
*   |   Check XPARM Parameter                           |
*   |     Get list of 1 to 38 byte job parameter in     |
*   |     the form of:                                  |
*   |                                                   |
*   |     XPARM=('ACBNAME=aaaaaaaa,TYPE=tttttttt')      |
*   |                                                   |
*   +---------------------------------------------------+
*
CHKXCP   EQU   *
         MVI   WSXCJPRM,C' '
         MVC   WSXCJPRM+1(L'WSXCJPRM-1),WSXCJPRM
         LA    R6,WSXCJPRM
         BAS   R14,COPYPARM           Perform copy parameter
         B     PARMNEXT               Get next parm
*
*   +---------------------------------------------------+
*   |                                                   |
*   |   Check TABLE or DESTTAB Parameter                |
*   |     Get 2 digit suffix of destination table       |
*   |                                                   |
*   +---------------------------------------------------+
*
CHKTAB   EQU   *
         MVC   WSTABLE(6),=C'XDITAB'
         MVC   WSTABLE+6(2),0(R2)
         OI    WSPFLAGS,WSPFTABL      Indicate table will be renew
         B     PARMNEXT               Get next parm
*
*   +---------------------------------------------------+
*   |                                                   |
*   |   Check CLASS or CLASSES Parameter                |
*   |     Get list of 1 to 8 sysout classes to be       |
*   |     a selection criteria                          |
*   |                                                   |
*   +---------------------------------------------------+
*
CHKCLS   EQU   *
         MVC   WSCLASSL,=8X'40'       Blank class list
         LA    R6,WSCLASSL            Point to target
         OI    WSPFLAGS,WSPFCLAS      Indicate that class parm done
         OI    WSPFLAGS,WSPFSSRQ      Indicate need re-SSREQ
         BAS   R14,COPYPARM           Perform copy parameter
         B     PARMNEXT               Get next parm
*
*   +---------------------------------------------------+
*   |                                                   |
*   |   Check RQCLASS Parameter                         |
*   |                                                   |
*   +---------------------------------------------------+
*
CHKRQC   EQU   *
         MVC   WSQCLASS,0(R2)         Get requeue class
         OI    WSQCLASS,C' '          Must uppercase
         B     PARMNEXT               Get next parm
*
*   +---------------------------------------------------+
*   |                                                   |
*   |   Check LRECL Parameter                           |
*   |     Get default LRECL to be used to create        |
*   |     flat dataset.   This parameter will be        |
*   |     overriden by one specified in the XDI         |
*   |     parmlib member.                               |
*   +---------------------------------------------------+
*
CHKLRL   EQU   *
         NI    WSPFLAGS,X'FF'-WSPFFORC 1stly ASIS
         CLC   =C'NORMAL',0(R2)       Is LRECL force to NORMAL  ?
         BNE   PARMNEXT               No, means ASIS
         OI    WSPFLAGS,WSPFFORC      Yes, indicate this parm
         B     PARMNEXT               Get next parm
*
*   +---------------------------------------------------+
*   |                                                   |
*   |   Check PCFORM Parameter                          |
*   |     Get default PC FORM to be used to create      |
*   |     flat dataset.   This parameter will be        |
*   |     overriden by one specified in the XDI         |
*   |     parmlib member.                               |
*   +---------------------------------------------------+
*
CHKFRM   EQU   *
         LA    R6,WSFORM              Point to target
         MVC   WSFORM,=CL8' '
         BAS   R14,COPYPARM           Copy the parm here
         CLC   =C'DISPATCH',WSFORM    Is FORM = DISPATCH ?
         BNE   WINDFRM                No, may be WINDOWS
         MVI   WSFFLAGS,WSFFDISP      Indicate FORM is DISPATCH
         B     OKEYFRM                Get next parm
WINDFRM  CLC   =C'WINDOWS',WSFORM     Is FORM = WINDOWS ?
         BNE   S390FRM                Get next parm
         MVI   WSFFLAGS,WSFFWIND      Indicate FORM is WINDOWS
         B     OKEYFRM                Get next parm
S390FRM  MVI   WSFFLAGS,WSFFS390      Indicate FORM is S/390 standard
OKEYFRM  EQU   *
         B     PARMNEXT               Get next parm
*
*   +---------------------------------------------------+
*   |                                                   |
*   |   Dynamic Parameter Copier (Variable Length)      |
*   |                                                   |
*   +---------------------------------------------------+
*
COPYPARM EQU   *
         CLI   0(R2),C' '             End of parm ?
         BE    COPYPEND               Yes, skip
         OC    0(1,R6),0(R2)          Take 1 byte parm
         LA    R6,1(,R6)              Next byte of target
         LA    R2,1(,R2)              Next byte of source
         BCT   R7,COPYPARM            Iterate
         BR    R14                    Return
COPYPEND EQU   *
         LA    R2,1(,R2)              Next byte of source
         BCTR  R7,0
         BR    R14                    Return
*
*   +---------------------------------------------------+
*   |                                                   |
*   |   Check Harddisk PC Drive Letter                  |
*   |                                                   |
*   +---------------------------------------------------+
*
CHKHDD   EQU   *
         MVC   WSPCHDD,0(R2)          Get HDD letter
         B     PARMNEXT               Get next parm
*
*   +---------------------------------------------------+
*   |                                                   |
*   |   Check DISP Parameter                            |
*   |     Get default sysout override disposition.      |
*   |     This parameter will be overriden by one       |
*   |     specified in the XDI parmlib member.          |
*   +---------------------------------------------------+
*
CHKDSP   EQU   *
         NI    WSOFLAGS,X'FF'-WSOFKEEP   Firstly DISP=DELETE
         CLC   =C'KEEP',0(R2)         Is DISP=KEEP ?
         BE    OKEYDSPK               Handle if so
         CLC   =C'DELETE',0(R2)       Is DISP=DELETE ?
         BE    OKEYDSP                Handle if so
         B     PARM_ERROR             Otherwise, signal error msg
OKEYDSPK EQU   *
         OI    WSOFLAGS,WSOFKEEP      Indicate DISP=KEEP
OKEYDSP  EQU   *
         B     PARMNEXT               Get next parm
         SPACE
*
*   +---------------------------------------------------+
*   |                                                   |
*   |   Check DISP Parameter                            |
*   |     Get default flat dataset disposition to be    |
*   |     specified in file LCLDS01 of XCOMJOB.  This   |
*   |     parameter will be overriden by one specified  |
*   |     in the XDI parmlib member.                    |
*   +---------------------------------------------------+
*
CHKXDS   EQU   *
         NI    WSOFLAGS,X'FF'-WSOFXKEP   Firstly XDISP=DELETE
         CLC   =C'KEEP',0(R2)         Is XDISP=KEEP ?
         BE    OKEYXDSK               Handle if so
         CLC   =C'DELETE',0(R2)       Is XDISP=DELETE ?
         BE    OKEYXDS                Handle if so
         B     PARM_ERROR             Otherwise, signal error msg
OKEYXDSK EQU   *
         OI    WSOFLAGS,WSOFXKEP      Indicate XDISP=KEEP
OKEYXDS  EQU   *
         B     PARMNEXT               Get next parm
         SPACE ,
*
*   +---------------------------------------------------+
*   |                                                   |
*   |   Check HOLD Parameter                            |
*   |     Get default held sysout processing.  Specify  |
*   |     HOLD=PROCESS indicate that held sysout file   |
*   |     will be accecpted to XDI processing.  Other-  |
*   |     wise, HOLD=IGNORE is assumed.                 |
*   +---------------------------------------------------+
*
CHKHLD   EQU   *
         CLC   =C'PROCESS',0(R2)      Is HOLD=PROCESS ?
         BE    OKEYHLDK               Handle if so
         CLC   =C'IGNORE',0(R2)       Is HOLD=IGNORE ?
         BE    OKEYHLD                Handle if so
         B     PARM_ERROR
OKEYHLDK EQU   *
         OI    WSOFLAGS,WSOFHOLD      Indicate XDISP=KEEP
OKEYHLD  EQU   *
         OI    WSPFLAGS,WSPFSSRQ      Indicate need re-SSREQ
         B     PARMNEXT               Get next parm
*
*   +---------------------------------------------------+
*   |                                                   |
*   |   Check TRACE Parameter                           |
*   +---------------------------------------------------+
*
CHKTRC   EQU   *
         NI    WSOFLAGS,X'FF'-WSOFTRAC Trace is off 1st
         CLC   =C'OFF',0(R2)          Is TRACE=OFF ?
         BE    OKEYTRC                Handle if so
         CLC   =C'ON',0(R2)           Is TRACE=ON ?
         BE    OKEYTRCY               Handle if so
         CLC   =C'NO',0(R2)           Is TRACE=OFF ?
         BE    OKEYTRC                Handle if so
         CLC   =C'YES',0(R2)          Is TRACE=ON ?
         BE    OKEYTRCY               Handle if so
         CLC   =C'N',0(R2)            Is TRACE=OFF ?
         BE    OKEYTRC                Handle if so
         CLC   =C'Y',0(R2)            Is TRACE=ON ?
         BNE   PARMNEXT               No, get next parm
OKEYTRCY EQU   *
         OI    WSOFLAGS,WSOFTRAC      Indicate trace is on
OKEYTRC  EQU   *
         B     PARMNEXT               Get next parm
PARM_ERROR     EQU *
         L     R2,0(,R1)              Restore parm
         @MESSAGE ERROR,OPCODE=B,OBJECT=(R2),TYPE=PARM,                +
               RC=*,EXIT=EXIT
PARMNEXT EQU   *
         TM    WSPFLAGS,WSPFFILE      Is it parmlib processing ?
         BZ    PARMCONT
         L     R2,WSIOREC             Access record
         C     R2,WSIOREC+4           Is it overlimit ?
         BNH   PARM_REC               No, continue next record
         BAS   R14,GET_PARM           Yes, try another block
         B     RVEWPARM               Go here if no more block
PARMCONT EQU   *
         TM    WSPFLAGS,WSPFCMND      Is it entered from command ?
         BO    RVEWPARM               Yes, review parms
         TM    0(R1),X'80'            Is it the last parm ?
         BO    RVEWPARM               Yes, review parms
         LA    R1,4(,R1)              Bump to next parm address
         B     CHKPARM               Iterate
         EJECT
*
*   +---------------------------------------------------+
*   |                                                   |
*   |   Read Parameter Table (XDISYSnn)                 |
*   |     - All parameter can be specified in this      |
*   |       table                                       |
*   |     - Inline parameter will override this table   |
*   +---------------------------------------------------+
*
GET_PARM EQU *
         STM   R0,R15,WSSAVEGR
         B     READ_BLOCK
OPEN_PARM      EQU *
         STM   R0,R15,WSSAVEGR
         @WTO  CODE=135,TRACE=ALWAYS
         L     R8,ADDR_PARMLIB           Capture Parmlib DCB map
         L     R7,DCBDCBE                Establish PARMLIB DCBE map
         MVC   WSEOPARM,DCBEEODA         Save EODAD in WSA
         MVC   DCBEEODA,=A(EOF_PARMLIB)  Set EOF exit routine address
*        MVC   DCBEODA,=AL3(EOF_PARMLIB) Set EOF exit routine address
         TM    DCBOFLGS,DCBOFOPN         Is it opened ?
         BO    READ_PARM                 Yes, read parmlib block
         OPEN  ((R8),(INPUT)),MF=(E,LOPEN_PARMLIB),MODE=31 Open PARMLIB
         TM    DCBOFLGS,DCBOFOPN         Is it work ?
         BO    OPEN_PARM_OKEY
         @MESSAGE ERROR,OPCODE=BZ,RC=(R15),                            +
               OPER=IO,TYPE=OPEN,OBJECT=DCBDDNAM,                      +
               EXIT=*
         @MESSAGE ERROR,OPCODE=BZ,OBJECT=(R2),TYPE=PARM,               +
               RC=*,EXIT=EXIT
         WTO   'DERXDP900E Trace: Unable to open parmlib '
         B     EXIT
OPEN_PARM_OKEY EQU *
*        WTO   'DERXDP902I Trace: Parmlib successfully opened'
         OI    WSPFLAGS,WSPFOPEN         Remember parmlib opened
         L     R1,WSIOBUF                 and save in WSA
         A     R1,WSIOBUF+4              Save buffer length
         ST    R1,WSIOREC+4              Save address of end of buffer
READ_PARM      EQU *
         L     R8,ADDR_PARMLIB           Capture Parmlib DCB map
         FIND  ((R8)),WSPARMM,D          Find the member
         LTR   R15,R15                   Check RC
         BZ    READ_BLOCK                Begin to read if RC = 0
         @MESSAGE WARNING,OPCODE=BNZ,RC=(R15),                         +
               OPER=IO,TYPE=FIND,OBJECT=WSPARMM,                       +
               EXIT=*
         @MESSAGE WARNING,OPER=FIND,RC=(R15),                          +
               TYPE=PARM,OBJECT=WSPARMM,EXIT=EXIT
         WTO   'DERXDP901E Trace: Unable to find parmlib member'
         B     EXIT
READ_BLOCK     EQU *
         L     R8,ADDR_PARMLIB           Capture Parmlib DCB map
         L     R5,WSIOBUF         Address of I/O buffer
         ST    R5,WSIOREC         Save 1st record address
         READ  XDIDECB,SF,(R8),(R5),'S',MF=E
         CHECK XDIDECB
         WTO   'DERXDP903I Trace: Parmlib block is being transferred'
         LH    R6,DCBLRECL        Get LRECL
         LH    R7,DCBBLKSI         and BLOCK SIZE
         LA    R7,0(R7,R5)        End of full block
         L     R1,XDIDECB+16      Address of IOB
         LH    R1,14(R1)          Residual count for short block
         SR    R7,R1              Adjust block length
         SR    R7,R6              Backward to the start of last record
         ST    R7,WSIOREC+4       Save address of last record
         WTO   'DERXDP904I Trace: Parmlib block transfer complete'
         LM    R0,R15,WSSAVEGR    Restore GPRs
         BR    R14                Return
EOF_PARMLIB    EQU   *
         L     R8,ADDR_PARMLIB           Capture Parmlib DCB map
         L     R7,DCBDCBE                Establish PARMLIB DCBE map
         MVC   DCBEEODA,WSEOPARM         Restore EODAD from WSA
RVEWPARM EQU   *
         @WTO  CODE=136,TRACE=ALWAYS
         TM    WSPFLAGS,WSPFCLAS      Have minimum parms done ?
         BNZ   SHOWPARM               Yes, just exit
         LA    R15,8                  Set RC = 8
         TM    WSPFLAGS,WSPFCLAS      Has CLASS parms done ?
         @MESSAGE ERROR,OPCODE=BZ,OBJECT='Initial parameter',          +
               RC=(R15),EXIT=EXIT
SHOWPARM EQU   *
         LA    R5,M_ENTRY
         TM    WSPFLAGS,WSPFFILE      Clear file indicator
         BZ    SHOW_CLASS
         LA    R5,M_FILE
         @MESSAGE INFO,OPER=SHOW,TYPE=PARM_FILE,                       +
               OBJECT=WSPARMM
SHOW_CLASS     EQU *
         @MESSAGE INFO,OPER=SHOW,TYPE=CLASS,                           +
               OBJECT=WSCLASSL,TEXT=(R5)
         MVC   WSDWORD,=CL8'  (only)'
         MVC   WSDWORD(1),WSQCLASS
         @MESSAGE INFO,OPER=SHOW,TYPE=REQUEUE_CLASS,                   +
               OBJECT=WSQCLASS,TEXT=(R5)
         CLI   WSFFLAGS,WSFFDISP      PC form = Dispatch ?
         BE    SHOW_FORM
         CLI   WSFFLAGS,WSFFWIND      PC form = Windows ?
         BE    SHOW_FORM
         MVI   WSFFLAGS,WSFFS390      Otherwise, must be S/390
         MVC   WSFORM,=CL8'S/390'
SHOW_FORM      EQU *
         @MESSAGE INFO,OPER=SHOW,TYPE=PCFORM,                          +
               OBJECT=WSFORM,TEXT=(R5)
         MVC   WSDWORD,=CL8'KEEP'
         TM    WSOFLAGS,WSOFKEEP
         BO    SHOW_DISP
         MVC   WSDWORD,=CL8'DELETE'
SHOW_DISP      EQU *
         @MESSAGE INFO,OPER=SHOW,TYPE=DISP,                            +
               OBJECT=WSDWORD,TEXT=(R5)
         MVC   WSDWORD,=CL8'KEEP'
         TM    WSOFLAGS,WSOFXKEP
         BO    SHOW_XDISP
         MVC   WSDWORD,=CL8'DELETE'
SHOW_XDISP     EQU *
         @MESSAGE INFO,OPER=SHOW,TYPE=XDISP,                           +
               OBJECT=WSDWORD,TEXT=(R5)
         MVC   WSDWORD,=CL8'PROCESS'
         TM    WSOFLAGS,WSOFHOLD
         BO    SHOW_HOLD
         MVC   WSDWORD,=CL8'IGNORE'
SHOW_HOLD      EQU *
         @MESSAGE INFO,OPER=SHOW,TYPE=HOLDFILE,                        +
               OBJECT=WSDWORD,TEXT=(R5)
         MVC   WSWORD,=CL4'ON'
         TM    WSOFLAGS,WSOFTRAC
         BO    SHOW_TRACE
         MVC   WSWORD,=CL4'OFF'
SHOW_TRACE     EQU *
         @MESSAGE INFO,OPER=SHOW,TYPE=TRACE,                           +
               OBJECT=WSWORD,TEXT=(R5)
         MVC   WSPCDRV(7),=CL7'HDD of'
         @MESSAGE INFO,OPER=SHOW,TYPE=PCDRIVE,                         +
               OBJECT=WSPCHDD,TEXT=(R5)
         MVC   WSDWORD,=CL8'ASIS'
         TM    WSPFLAGS,WSPFFORC          Is it forced ?
         BZ    SHOW_REC_HANDLING
         MVC   WSDWORD,=CL8'FORCED'
SHOW_REC_HANDLING EQU *
         @MESSAGE INFO,OPER=SHOW,TYPE=REC_HANDLING,                    +
               OBJECT=WSDWORD,TEXT=(R5)
         @XCOMJOB EXEC,                                                +
               PREFIX=XC,LOC=*,                                        +
               JOBPARM=WSXCJPRM,                                       +
               STEPLIB=WSSTPLIB,                                       +
               CAILIB=WSCAILIB,                                        +
               RESTLIB=WSRSTLIB,                                       +
               GLOBLIB=WSGLBLIB,                                       +
               CNTLLIB=WSCTLLIB,                                       +
               PCDRIVE=WSPCHDD
         B     EXIT
M_ENTRY  DC   AL2(L'MT_ENTRY)
MT_ENTRY DC   C'from direct entry  '
M_FILE   DC   AL2(L'MT_FILE)
MT_FILE  DC   C'from parmlib member  '
         EJECT
         DS   0H
         EJECT
*
*   +---------------------------------------------------+
*   |                                                   |
*   |   Read Destination Table (XDITABnn)               |
*   |     - Set of destination of recipient can only    |
*   |       specified via this table                    |
*   |     - There is no default for destinataion        |
*   +---------------------------------------------------+
*
DEST_TABLE    EQU *
         MVC   WSTABLE(6),=C'XDITAB'     Specify membername
         MVC   WSTABLE+6(2),8(R2)        Take suffix
UPDATE_TABLE  EQU *
         L     R8,ADDR_PARMLIB           Capture Parmlib DCB map
         L     R7,DCBDCBE                Establish PARMLIB DCBE map
         MVC   WSEOPARM,DCBEEODA         Save EODAD in WSA
         MVC   DCBEEODA,=A(EOF_TABLE)    Set EOF exit routine address
         TM    DCBOFLGS,DCBOFOPN         Is it opened ?
         BO    OPEN_TABLE_OKEY           Yes, read table block
         OPEN  ((R8),(INPUT)),MF=(E,LOPEN_PARMLIB),MODE=31 Open PARMLIB
         TM    DCBOFLGS,DCBOFOPN         Is it work ?
         BO    OPEN_TABLE_OKEY
         @MESSAGE ERROR,OPCODE=BZ,RC=(R15),                            +
               OPER=IO,TYPE=OPEN,OBJECT=WSTABLE,                       +
               EXIT=*
         @MESSAGE ERROR,OPCODE=BZ,OBJECT=(R2),TYPE=TABLE,              +
               RC=*,EXIT=EOF_TABLE
         B     EOF_TABLE
OPEN_TABLE_OKEY EQU *
         L     R8,ADDR_PARMLIB       Capture Parmlib DCB map
         FIND  ((R8)),WSTABLE,D      Check if TABLE name exist
         ST    R15,WSRCODE             Save RC
         LTR   R15,R15               Check RC
         BZ    READ_TABLE            Go straight if RC =  0
         @MESSAGE WARNING,OPCODE=BNZ,RC=(R15),                         +
               OPER=IO,TYPE=FIND,OBJECT=WSTABLE,                       +
               EXIT=*
         L     R15,WSRCODE           Restore RC
         @MESSAGE WARNING,OPER=FIND,RC=(R15),                          +
               TYPE=TABLE,OBJECT=WSTABLE,EXIT=*
         B     EOF_TABLE
READ_TABLE     EQU *
         LM    R2,R3,WSDESTP      Pointer and number of dest
         LTR   R2,R2              Has it initialized ?
         BZ    GET_VS_TABLE
         SLL   R3,3               Multiply to number of byte
         STORAGE RELEASE,ADDR=(R2),LENGTH=(R3)
GET_VS_TABLE   EQU *
         L     R3,WSIOBUF+4
         SLL   R3,1              At least 2 x I/O buffer
         STORAGE OBTAIN,LENGTH=(R3)
         ST    R1,WSDESTP         Save pointer
         SRL   R0,3               Divided by 8
         ST    R0,WSDESTP+4       and save it
         @WTO  CODE=107              Get parmlist address
         LM    R2,R3,WSDESTP      Top of table & # dest
READ_TABLE_BLOCK EQU *
         L     R5,WSIOBUF         Address of I/O buffer
         READ  XDIDECB,SF,(R8),(R5),'S',MF=E
         CHECK XDIDECB
         LH    R6,DCBLRECL        Get LRECL
         LH    R7,DCBBLKSI         and BLOCK SIZE
         LA    R7,0(R7,R5)        End of full block
         L     R1,XDIDECB+16      Address of IOB
         LH    R1,14(R1)          Residual count for short block
         SR    R7,R1              Adjust block length
         SR    R7,R6              Backward to the start of last record
READ_TABLE_RECORD EQU *
         CLI   0(R5),C'*'         Is comment ?
         BE    READ_TABLE_NEXT    Yes, skip this record
         CLI   0(R5),C' '         Is blank ?
         BE    READ_TABLE_NEXT    Yes, skip this record
         CLI   0(R5),X'00'        Is null ?
         BE    READ_TABLE_NEXT    Yes, skip this record
         MVC   0(8,R2),0(R5)      Get in the destination name
         LA    R2,8(,R2)          Next dest
         BCT   R3,READ_TABLE_NEXT
         L     R3,WSDESTP+4
         SLL   R3,4
         STORAGE OBTAIN,LENGTH=(R3)
         ST    R1,WSDWORD
         ST    R0,WSDWORD+4
         LR    R2,R1              Address
         LM    R0,R1,WSDESTP
         SLL   R1,3
         LR    R3,R1
MVCL_LOOP EQU  *
         MVCL  R2,R0
         LTR   R1,R1
         BC    1,MVCL_LOOP
         ST    R2,WSWORD          Position of unfilled new buffer
         LM    R2,R3,WSDESTP      Old table
         SLL   R3,3               Zoom to # bytes
         STORAGE RELEASE,ADDR=(R2),LENGTH=(R3)
         LM    R2,R3,WSDWORD      New table
         SRL   R3,3               # of dest
         STM   R2,R3,WSDESTP      Save new table
         L     R2,WSWORD          Resume position
         LR    R15,R2
         S     R15,WSDESTP        Offset
         L     R3,WSDWORD+4       Length of table
         SR    R3,R15             Length beyond last position
         SRL   R3,3               Rest # dest
READ_TABLE_NEXT EQU *
         BXLE  R5,R6,READ_TABLE_RECORD  Search next record in block
         B     READ_TABLE_BLOCK         Iterate to read next block
EOF_TABLE EQU  *
         MVC   0(8,R2),=CL8'/*EOF '
         NI    WSPFLAGS,X'FF'-WSPFTABL   Clear indicator
         MVC   WSDESTP1(8),WSDESTP      Set hot position
         MVC   DCBEEODA,WSEOPARM        Restore EODAD from WSA
         @MESSAGE INFO,OPER=SHOW,TYPE=DEST_TABLE,                      +
               OBJECT=WSTABLE
         LM    R2,R3,WSDESTP            Pointer and number of dest
TABLE_SHOW_LOOP EQU *
         CLC   =C'/*EOF ',0(R2)         End of table ?
         BE    TABLE_SHOW_END           Yes, end loop
         MVC   WSDWORD,0(R2)
         @MESSAGE INFO,OPER=LIST,TYPE=DESTID,                          +
               OBJECT=WSDWORD,TEXT='accepted and applied.'
         LA    R2,8(R2)
         BCT   R3,TABLE_SHOW_LOOP
TABLE_SHOW_END EQU *
*
*  +--------------------------------------------------------------+
*  |  Exit procedure                                              |
*  |    (1)  Tell JES that interaction is finished.               |
*  |    (2)  Free SSOB/SSSO storage area.                         |
*  |    (3)  Restore system savearea address                      |
*  |    (4)  Disconnect DERWTR and DERWTX                         |
*  |    (5)  Free WSA                                             |
*  |    (6)  Restore states                                       |
*  |    (7)  Return to MVS                                        |
*  |                                                              |
*  +--------------------------------------------------------------+
*
         DS    0H
EXIT     EQU   *
         TM    WSPFLAGS,WSPFTABL      Is update table requested ?
         BO    UPDATE_TABLE           Yes, handle it
QUIT     EQU   *
*        LM    R2,R3,WSIOBUF            I/O buffer address & size
*        STORAGE RELEASE,ADDR=(R2),LENGTH=(R3)   Release the buffer
         @EXIT
         LTORG ,
         EJECT
*
* +--------------------------------+
* | Working Storage Area Map       |
* | Used as working set and other  |
* | dynamic storages directory     |
* +--------------------------------+
*
         DERWSA
         EJECT ,
*
* +--------------------------------+
* | Module Extension Area Map      |
* | Used as a non reentrant part   |
* | of this module                 |
* +--------------------------------+
*
         DERWTX TYPE=DSECT
*
* +--------------------------------+
* | Command interaction buffer     |
* | used to interfacing operator   |
* | console transaction            |
* +--------------------------------+
*
         DERCIB TYPE=DSECT
*        @EPILOG
*
*   STANDARD MVS SOURCE COPY
*   FOR DSECTS AND EQUATES
*   ------------------------
*
         CVT   DSECT=YES
         DCBD  DSORG=(PO,PS)
         IHADCBE
         IEFJESCT TYPE=DSECT,MNTBL=YES
         IEFJSSOB (SO,AG,AL),CONTIG=YES
         IEFZB4D0
*        IEFZB4D2
         END   DERXDP
./ ADD NAME=DERXDS   0100-01324-01324-1743-00340-00340-00000-DERU-S
**********************************************************************
*
*                     +---------+
*     Module Name  -  | DERXDS  |
*                     +---------+
*                     CA-Dispatch -to- CA-XCOM Handshaking Interface
*
*     Function -
*            Activate local external writer and establish handshaking
*            between CA-Dispatch and CA-Xcom
*
*     Operating Environment -
*        Type              MVS System Program
*        Min. Auth.        Supervisor state
*        Dsp.unit mode     Task
*        AMODE             24-bit or 31-bit
*        XM                PASN=HASN=SASN
*        ASC mode          Primary
*        Interrupt status  Enabled for I/O and Ext. interrupts
*        Locks             No locks held
*        Control Parm      The SSOB and SSSO control blocks can
*                          reside in storage above 16 megabytes.
*        Recovery          Program should provide an ESTAE-type
*                          recovery environment. See MVS/ESA SP V5
*                          Auth Assembler Services Guide for more info
*                          an ESTAE-type recovery environment.
*
*
*     Syntax -
*          In Cataloged Procedure JCL
*
*  |           //stepname EXEC PGM=DERXDS,                           |
*  |           //            PARM='CLASSES=cccccccc,FORM=ffffffff'   |
*  |               cccccccc = List up to 8 classes to be captured    |
*  |               ffffffff = Form of recipient, i.e. FORM=DISPATCH  |
*  |                                                                 |
*          Or From Console Interaction
*  |                                                                 |
*  |           F Procname,Classes={ccccc}                            |
*
*
*     Operation -
*
*
*     Register Usage -
*          R0-R1   -->  System interface
*          R2-R7   -->  Work registers
*          R8      -->  Counter
*          R9      -->  Module extension base address
*          R10     -->  WSA (working storage area) address
*          R11     -->  SSSO block address
*          R12     -->  Main module base address
*          R13     -->  Conventional savearea
*          R14     -->  BAS or BASR return address
*          R15     -->  Return code
*
*     Author -
*          Name     :  Deru Sudibyo
*                      Technical Consultant
*                      Computer Associates
*                      Indonesia Office
*                      Wisma BNI-46 34th floor, BNI-46 City
*                      Jl. Jend. Sudirman, Kav 1, Jakarta Pusat
*          Copyright:  (C)1998 Deru Sudibyo
*
*     Disclaimer -
*         This module is developed as a personal support, and is
*         not a part of CA support matterials.  The purpose is as
*         a temporary solution or even just a sample.  Therefor,
*         further modifications and maintenance are client's
*         responsibilities.
*
*     Modification Log -
*     +--------+------------+--------+---------------------------+
*     | Date   | Engineer   | V.R.L. | Description               |
*     +--------+------------+--------+---------------------------+
*     |98/02/12| Deru S.    | 1.0.0. | First development         |
*     |        |            |        |                           |
*     |        |            |        |                           |
*     |        |            |        |                           |
*     |        |            |        |                           |
*     |        |            |        |                           |
*     |        |            |        |                           |
*     +--------+------------+--------+---------------------------+
*
*
         EJECT ,
DERXDS   @PROLOG ESA=390,                                              +
               AMODE=31,                                               +
               RMODE=ANY,                                              +
               RENT=YES,                                               +
               BREG=R12
*
         USING DERWTX,R9          Establish Module extension logic map
         USING WSA,R10            Establish WSA structure map
         USING SSOB,R11           Establish SSOB structure map
*
*        LR    R10,R1             Enable WSA map
*        L     R9,WSMODWTX        Enable WTX map
*
         LOAD  EP=DERWSA
         LR    R10,R0             Establish WSA mapping
         LOAD  EP=DERWTX
         LR    R9,R0              Establish WTX mapping
         CLI   WSSOWRTR,C' '           Is writer name there ?
         BE    NONAME                  No, proceed
         CLI   WSSOWRTR,X'00'          Null ?
         BNE   GOOD_EXIT               Otherwise, may fine sysout
NONAME   EQU   *
         L     R11,WSSSOB         Establish SSOB mapping
         TM    SSSOFLG5,SSSOGNVA       Is outgroup name provided ?
         BZ    NO_OUTGROUP             Give default name and exit
         MVI   SSSOFLG2,SSSOCTRL   Indicate FINAL CALL to JES2
         MODESET MF=(E,LMODSUPZ)   Enter to SUPERVISOR MODE
         LA    R1,WSSSOBP          POINT TO SSOB POINTER
         IEFSSREQ ,                Go to JES for give back
         MODESET MF=(E,LMODPRON)   Back to PROBLEM MODE
         BAS   R14,INIT_REQUEUE
         MVC   0(1,R2),WSQCLASS         Complete cmd text with class
         BAS   R14,INIT_SSOB
         MVC   SSSOCLSL,WSCLASSL      Restore CLASS list
         MVC   SSSODEST,WSSODEST      Restore DEST
         OI    SSSOFLG1,SSSODST       and its request
         MODESET MF=(E,LMODZERO)
         LM    R0,R1,WSCMDPRM           Get cmd parameter list
         SVC   34                       Schedule command
         MODESET MF=(E,LMODNZER)
         MVC   WSSOGRNM,SSSOOGNM       Save group name
         L     R1,WSSSOB1              Address of SSOB pointer
         ST    R1,WSSSOBP              Save pointer
         OI    WSSSOBP,X'80'           Mark as the only ptr in the list
         XR    R8,R8                   CLear counter
         LA    R8,1(R8)                Increment counter
         MVC   WSWORD,=A(WAIT_SYSOUT)
LOOP_SSREQ     EQU *
         L     R11,WSSSOB1             Point to parmlist and
         BAS   R14,INIT_SSOB           Initialize SSOB
         MVC   SSSOCLSL,WSLCLASS       Set CLASS list for request
         @WTO  CODE=106             Get parmlist address
SEND_SSREQ     EQU *
         MODESET MF=(E,LMODSUPZ)       Enter to SUPERVISOR mode key 0
         LA    R1,WSSSOBP              Point to the SSOB parmlist
         IEFSSREQ ,                    Send SUBSYSTEM REQUEST
         LR    R5,R15                  Save RC
         MODESET MF=(E,LMODPRON)       Back to PROBLEM mode
         LTR   R15,R5                  Check RC
         BNZ   ERROR_SSI               Error if not 0
         L     R14,WSWORD
         L     R15,SSOBRETN            Check SSOB RC
         LTR   R15,R15                 Is it 0
         BZ    FOUND_SYSOUT            Ya, sysout found
         CH    R15,=H'4'               Must we wait for ?
         BER   R14                     Go to wait or exit
*        BE    WAIT_SYSOUT             Yes if RC = 4
         B     ERROR_SSOB              Otherwise must be serious error
WAIT_SYSOUT    EQU *
         MVC   WSWORD,=A(LOST_SYSOUT)
         CH    R8,=H'2'                Check counter
         BNL   LOST_SYSOUT             Assume lost if recycled
         LA    R8,1(R8)                Increment counter
         MODESET MF=(E,LMODSUPZ)       Enter to SUPERVISOR mode
         L     R2,SSSOWTRC             Point to JES/WTR comm. area
         WAIT  ECB=(R2)                Wait for JES
         MODESET MF=(E,LMODPRON)       Enter to PROBLEM mode
         B     SEND_SSREQ              Retry send SSREQ
FOUND_SYSOUT   EQU *
         MVC   WSWORD,=A(LOST_SYSOUT)
         TM    WSOFLAGS,WSOFTRAC       Is trace enabled ?
         BZ    CHECK_SYSOUT            Keep silenc
         @MESSAGE INFO,OPER=SHOW,TYPE=JOBNAME,                         +
               OBJECT=SSSOJOBN,TEXT='captured ....'
         @MESSAGE INFO,OPER=SHOW,TYPE=JOBID,                           +
               OBJECT=SSSOJOBI,TEXT='captured ....'
         @MESSAGE INFO,OPER=SHOW,TYPE=DEST,                            +
               OBJECT=SSSODEST,TEXT='captured ....'
         @MESSAGE INFO,OPER=SHOW,TYPE=WRTRNAME,                        +
               OBJECT=SSSOPGMN,TEXT='captured ....'
         @MESSAGE INFO,OPER=SHOW,TYPE=OUTGRP,                          +
               OBJECT=SSSOOGNM,TEXT='captured ....'
         @MESSAGE INFO,OPER=SHOW,TYPE=DSN,                             +
               OBJECT=SSSODSN,TEXT='captured ....'
CHECK_SYSOUT   EQU *
         CLC   WSSODSN,SSSODSN         Is it the same sysout ?
*        BNE   REQUEUE_SYSOUT          No, requeue back to wait class
*        TM    SSSOFLG5,SSSOGNVA       Is outgroup name provided ?
*        BZ    REQUEUE_SYSOUT          No, requeue back to wait class
*        CLC   WSSOGRNM,SSSOOGNM       Is it the same sysout ?
         BE    SAME_SYSOUT             Yes, proceed
REQUEUE_SYSOUT EQU *
         MVI   SSSOFLG2,SSSOCTRL   Indicate FINAL CALL to JES2
         MODESET MF=(E,LMODSUPZ)   Enter to SUPERVISOR MODE
         LA    R1,WSSSOBP          POINT TO SSOB POINTER
         IEFSSREQ ,                Go to JES for give back
         MODESET MF=(E,LMODPRON)   Back to PROBLEM MODE
         BAS   R14,INIT_REQUEUE
         MVC   0(1,R2),WSCLASSL        Complete cmd text with class
         MODESET MF=(E,LMODZERO)
         LM    R0,R1,WSCMDPRM           Get cmd parameter list
         SVC   34                       Schedule command
         MODESET MF=(E,LMODNZER)
         B     LOOP_SSREQ              Redo SSREQ
SAME_SYSOUT    EQU *
         CLI   SSSOPGMN,C' '           Is writer name there ?
         BE    SYSOUT_NONAME           No, give the default name
         CLI   SSSOPGMN,X'00'          Null ?
         BE    SYSOUT_NONAME           Yes, give default name
         MVC   WSSOWRTR,SSSOPGMN       Otherwise, take writer name
         B     GOOD_EXIT               Exit
SYSOUT_NONAME  EQU *
         @WTO  CODE=185
         MVC   WSSOWRTR,=CL8'NONAME'   Otherwise, take writer name
GOOD_EXIT      EQU *
         LA    R15,0                   Set RC = 0
         B     EXIT                    Then, exit
*
*  +--------------------------------------+
*  ¦                                      ¦
*  ¦  Initialize SSOB                     ¦
*  ¦                                      ¦
*  +--------------------------------------+
*
INIT_SSOB      EQU *
         XC    SSOBEGIN(SSOBLEN1),SSOBEGIN   Clear SSOB & SSSO
         MVC   SSOBID,=CL4'SSOB'       Put Block ID (eyecatcher)
         MVC   SSOBLEN,=AL2(SSOBHSIZ)  Specify SSOB length
         MVC   SSSOLEN,=AL2(SSSOSIZE)  Specify SSSO length
         LA    R4,SSSOBGN              Point to extension address
         ST    R4,SSOBINDV              and keep it in header
         OI    SSSOVER,SSSOCVER        Set as current version number
         MVC   SSOBFUNC,=AL2(SSOBSOUT) Select SSI SYSOUT function
         OI    SSSOFLG2,SSSOPSEE       Process sysout extension
         OI    SSSOFLG1,SSSOSCLS       CLASSes are selection criterion
         BR    R14
*
*  +--------------------------------------+
*  ¦                                      ¦
*  ¦  Initialize Requeue JES Command      ¦
*  ¦                                      ¦
*  +--------------------------------------+
*
INIT_REQUEUE   EQU *
         MVI   WSCMDBUF,C' '
         MVC   WSCMDBUF+1(L'WSCMDBUF-1),WSCMDBUF
         MVC   WSCMDBUF+2(16),=CL16'$TOSjjjj,OUTGRP='
         MVC   WSCMDBUF+5(1),SSSOJOBI       jobid 1st byte
         MVC   WSCMDBUF+6(4),SSSOJOBI+4     jobid byte 5-8
         LA    R2,WSCMDBUF+18           Target address
         LA    R3,SSSOOGNM              Source address
         LA    R4,L'SSSOOGNM            Length of source
LOOP     EQU   *
         CLI   0(R3),C' '               Is it blank ?
         BE    SKIP                     Skip if so
         CLI   0(R3),X'00'              Is it null ?
         BE    SKIP                     Skip if so
         CLI   0(R3),X'FF'              Is it FF ?
         BE    SKIP                     Skip if so
         MVC   0(1,R2),0(R3)            Copy character
         LA    R2,1(R2)                 Next target
SKIP     EQU   *
         LA    R3,1(R3)                 Next source
         BCT   R4,LOOP                  Iterate
         MVC   0(3,R2),=C',Q='          Put next cmd text
         LA    R2,3(R2)
         BR    R14
*
*  +--------------------------------------+
*  ¦                                      ¦
*  ¦  Error and Normal Exit Routines      ¦
*  ¦                                      ¦
*  +--------------------------------------+
*
NO_OUTGROUP    EQU *
         @WTO  CODE=184
         LA    R15,4                Set RC = 4
         B     SYSOUT_NONAME        Exit
LOST_SYSOUT    EQU *
         @WTO  CODE=186
         LA    R15,8                Set RC = 8
         B     EXIT                 Exit
ERROR_SSI      EQU *
         @WTO  CODE=187
         LA    R15,12               Set RC = 16
         B     EXIT                 Exit
ERROR_SSOB     EQU *
         @WTO  CODE=188
         LA    R15,16               Set RC = 16
         B     EXIT                 Exit
EXIT     EQU   *
         L     R1,WSSSOB               Address of SSOB pointer
         ST    R1,WSSSOBP              Save pointer
         OI    WSSSOBP,X'80'           Mark as the only ptr in the list
         @EXIT
         LTORG ,
         EJECT
*
* +--------------------------------+
* | Working Storage Area Map       |
* | Used as working set and other  |
* | dynamic storages directory     |
* +--------------------------------+
*
         DERWSA
         EJECT ,
*
* +--------------------------------+
* | Module Extension Area Map      |
* | Used as a non reentrant part   |
* | of this module                 |
* +--------------------------------+
*
         DERWTX TYPE=DSECT
*
*   STANDARD MVS SOURCE COPY
*   FOR DSECTS AND EQUATES
*   ------------------------
*
         PRINT NOGEN
         DERTABCC
         CVT   DSECT=YES
         DCBD  DSORG=(PO,PS)
         IHADCBE
         IEFJESCT TYPE=DSECT,MNTBL=YES
         EJECT ,
*
*   +----------------------------------------+
*   ¦  SSOB                                  ¦
*   ¦      SSOB-header/                      ¦
*   ¦                / SSSO                  ¦
*   ¦                                        ¦
*   +----------------------------------------+
*
         PRINT NOGEN
         IEFSSOBH
         ORG   ,
SSOBGN   EQU   *
         IEFSSSO SOEXT=YES
SSSO_END EQU   *
         IEFZB4D0
*        IEFZB4D2
         END   DERXDS
./ ADD NAME=DERXIO   0100-01324-01324-1743-00670-00670-00000-DERU-S
**********************************************************************
*
*                     +---------+
*     Module Name  -  | DERXIO  |
*                     +---------+
*                     Local External Writer Component to Support
*                     CA-Dispatch and CA-XCOM Handshaking
*
*     Function -
*            Output writer routine to copy sysout into flat dataset
*            files and submit XCOMJOB.
*
*     Operating Environment -
*        Type              MVS System Program
*        Min. Auth.        Supervisor state
*        Dsp.unit mode     Task
*        AMODE             24-bit or 31-bit
*        XM                PASN=HASN=SASN
*        ASC mode          Primary
*        Interrupt status  Enabled for I/O and Ext. interrupts
*        Locks             No locks held
*        Control Parm      The SSOB and SSSO control blocks can
*                          reside in storage above 16 megabytes.
*        Recovery          Program should provide an ESTAE-type
*                          recovery environment. See MVS/ESA SP V5
*                          Auth Assembler Services Guide for more info
*                          an ESTAE-type recovery environment.
*
*
*     Syntax -
*          None
*
*     Operation -
*
*
*     Register Usage -
*          R0-R1   -->  System interface
*          R2-R7   -->  Work registers
*          R8      -->  DCB map (IHADCB) address
*          R9      -->  Module extension base address
*          R10     -->  WSA (working storage area) address
*          R11     -->  Main module base address
*          R12     -->  Main module base address
*          R13     -->  Conventional savearea
*          R14     -->  BAS or BASR return address
*          R15     -->  Return code
*
*     Author -
*          Name     :  Deru Sudibyo
*                      Technical Consultant
*                      Computer Associates
*                      Indonesia Office
*                      Wisma BNI-46 34th floor, BNI-46 City
*                      Jl. Jend. Sudirman, Kav 1, Jakarta Pusat
*          Copyright:  (C)1998 Deru Sudibyo
*
*     Disclaimer -
*         This module is developed as a personal support, and is
*         not a part of CA support matterials.  The purpose is as
*         a temporary solution or even just a sample.  Therefor,
*         further modifications and maintenance are client's
*         responsibilities.
*
*     Modification Log -
*     +--------+------------+--------+---------------------------+
*     | Date   | Engineer   | V.R.L. | Description               |
*     +--------+------------+--------+---------------------------+
*     |98/02/12| Deru S.    | 1.0.0. | First development         |
*     |        |            |        |                           |
*     |        |            |        |                           |
*     |        |            |        |                           |
*     |        |            |        |                           |
*     |        |            |        |                           |
*     |        |            |        |                           |
*     +--------+------------+--------+---------------------------+
*
*
         EJECT ,
DERXIO   @PROLOG ESA=390,                                              +
               AMODE=31,                                               +
               RMODE=ANY,                                              +
               RENT=YES,                                               +
               BREG=(R11,R12)
*
         USING DCBE,R7            Establish DCBE structure map
         USING IHADCB,R8          Establish DCB structure map
         USING DERWTX,R9          Establish Module extension logic map
         USING WSA,R10            Establish WSA structure map
*
         LOAD  EP=DERWSA
         LR    R10,R0             Enable WSA addressability
         LOAD  EP=DERWTX
         LR    R9,R0              Enable WTX addressability
         LOAD  EP=DERDCB
BEGIN    EQU   *
         XC    WSRCODE,WSRCODE    Clear RC
         MVC   ADDR_IEFRDER,ADDR_LCLDS01  Backup LCLDS01 DCB pointer
         EJECT ,
*********************************************************************
*
*   ALLOCATE SYSOUT and FLATFILE Datasets
*   -------------------------------------
*
*   (1)  Allocate sysout dataset as SYSOUT with DSN copied from
*        SSOB and request is passed to subsystem named JES2.
*
*   (2)  Create XCOMJOB JCL which includes
*          - Obtain system date and time
*          - Construct flatfile DSN that describe Recipient-id
*            (DESTid copied from SSOB), current system date and time,
*            and Report-id (WTR-name from SSOB)
*
*   (3)  Allocate flatfile dataset as LCLDS01 with DSN copied
*        from (2), Lrecl copied from SSOB, Blkzise 6233 and all
*        other space parameters just estimated.
*
*   (4)  Check whether remote destination from is DISPATCH.  If so,
*        prepare all DISPATCH page headers.
*
*   (5)  Return.
*
         DS    0H
ALLOC    EQU *
         @EDITTOD FORMAT=BOTH
         @WTO  CODE=157
*
*  +-----------------------------------------------------------+
*  ¦   Allocate JES2FILE                                       ¦
*  ¦      o  Type sysout                                       ¦
*  ¦      o  Input                                             ¦
*  ¦      o  Mapped by ARB & ARBP block in WTX                 ¦
*  ¦      o  DD name taken from DCB                            ¦
*  ¦                                                           ¦
*  +-----------------------------------------------------------+
*
         L     R8,ADDR_JES2FILE       Access of sysout DCB
         L     R7,DCBDCBE
*        MVC   DCBLRECL,WSSOMLRL      Set max lrecl
         MVC   DCBEEODA,=A(SPOOL_END) Prepare EOD exit routine
         MVC   DCBESYNA,=A(SPOOL_SYN) Prepare SYN exit routine
         @DYNAMIC ALLOCATE,           Prepare sysout SVC 99 parm       +
               DSN=WSSODSN,           Copy DSN from SSSODSN            +
               PREFIX=A,              The prefix is A                  +
               GETDD=DCBDDNAM,        Copy DD into JES2FILE' DCB       +
               ERRMSG=WTO,            Display error msg using WTO      +
               LOC=*                  Inline
         LTR   R15,R15                Check RC
         BZ    ALLOC_SO_OKEY
         A     R15,WSRCODE            Accumulate RC
         ST    R15,WSRCODE
         OI    WSEFLAGS,WSEFERRP      Remember this error
         @MESSAGE ERROR,OPCODE=B,OPER=DYNALLOC,TYPE=ALLOC,             +
               OBJECT=WSSODSN,RC=ARBERR,EXIT=ERROR_EXIT
ALLOC_SO_OKEY  EQU *
         @DYNAMIC UPDATE,LOC=*,       Prepare sysout SVC 99 parm       +
               PREFIX=D,              The prefix is D                  +
               DD=DCBDDNAM,           Use DD name of JES2FILE          +
               ERRMSG=WTO,            Display error msg using WTO      +
               DYNALLC=NO
         @WTO  CODE=158
         OI    WSSFLAGS,WSSFAJES      Remember JES2FILE allocated
         CP    WSCOUNT,=P'999999'     Has maximum count reached ?
         BL    ALLOC_GO               No, go ahead
         ZAP   WSCOUNT,=PL1'0'        Yes, reset counter
ALLOC_GO EQU   *
         OI    WSCOUNT+L'WSCOUNT-1,X'0F'
         UNPK  WSJNUM,WSCOUNT         Mark jobname of XCnnnnnn
*
*  +-----------------------------------------------------------+
*  ¦   Prepare Dataset Name for Output                         ¦
*  ¦      o  Type flat file                                    ¦
*  ¦      o  Name CADS.XDOM.Destid.Rptname.Date.Time           ¦
*  ¦      o  Addressed by GPR 1                                ¦
*  +-----------------------------------------------------------+
*
         @EDITDSN RPTNAME=WSSOWRTR,   From SSSOPGMN                    +
               RCPID=WSSODEST,        From SSSODEST                    +
               DSHLQ=CADS.XCOM,       Use this prefix                  +
               DSN=WSFFDSN            And save here the result
*
*  +-----------------------------------------------------------+
*  ¦   Prepare JCL for XCOM Job                                ¦
*  ¦      o  Type batch job                                    ¦
*  ¦      o  Name XCDestid                                     ¦
*  ¦      o  Mapped by XCJOB in WTX                            ¦
*  +-----------------------------------------------------------+
*
         TM    WSPFLAGS,WSPFOVER      Is form overriden ?
         BZ    CHECK_XDISP
         TM    WSOVFLGS,WSOFXKEP      DISP=KEEP requested ?
         BO    XDISP_KEEP             Yes, make it work
         B     XDISP_DELETE
CHECK_XDISP    EQU *
         TM    WSOFLAGS,WSOFXKEP      DISP=KEEP requested ?
         BO    XDISP_KEEP             Yes, make it work
XDISP_DELETE   EQU *
         @XCOMJOB BUILD,                                               +
               PREFIX=XC,                                              +
               JOBPARM=WSXCJPRM,                                       +
               LOC=*,DSN=WSFFDSN,                                      +
               RPTNAME=WSSOWRTR,      From SSSOPGMN                    +
               RCPID=WSSODEST,        From SSSODEST                    +
               DISP='(OLD,DELETE)',                                    +
               JOBNUM=WSJNUM
         B     EDIT_HEADER
XDISP_KEEP     EQU *
         @XCOMJOB BUILD,                                               +
               PREFIX=XC,                                              +
               JOBPARM=WSXCJPRM,                                       +
               LOC=*,DSN=WSFFDSN,                                      +
               RPTNAME=WSSOWRTR,        From SSSOPGMN                  +
               RCPID=WSSODEST,          From SSSODEST                  +
               DISP='(OLD,KEEP)',                                      +
               JOBNUM=WSJNUM
*
*  +-----------------------------------------------------------+
*  ¦   Prepare Header for Dispatch Format Only                 ¦
*  ¦      o  First page                                        ¦
*  ¦          Header line 1 mapped by PH1 in WTX               ¦
*  ¦          Header line 2 mapped by PH2 in WTX               ¦
*  ¦          Header line 3 mapped by PH3 in WTX               ¦
*  ¦      o  Subsequent Pages                                  ¦
*  ¦          Header line 3 mapped by PH3 in WTX               ¦
*  +-----------------------------------------------------------+
*
EDIT_HEADER    EQU *
         @EDITHDR UPDATE,LOC=*,                                        +
               RCPID=WSSODEST,          From SSSODEST                  +
               RPTNAME=WSSOWRTR,        From SSSOPGMN                  +
               DATE=INTERNAL,                                          +
               TIME=INTERNAL,                                          +
               PREFIX=PH
         AP    WSCOUNT,=PL1'1'      Increment counter
         ZAP   WSPGNUM,=PL1'0'      Initialize page number
*
*  +-----------------------------------------------------------+
*  ¦   Open JES2FILE                                           ¦
*  ¦      o  Type J                                            ¦
*  ¦          Must in AMODE 34                                 ¦
*  ¦      o  DCB pointed by ADD_JES2FILE                       ¦
*  ¦          It prepared by caller                            ¦
*  +-----------------------------------------------------------+
*
         L     R8,ADDR_JES2FILE       Establish DCB addressability
OPEN_SO  EQU   *
         OPEN  ((R8),(INPUT)),MODE=31,   Open DCB of sysout            +
               MF=(E,LOPEN_JES2FILE)
         TM    DCBOFLGS,DCBOFOPN         Is it work ?
         BNZ   CHECK_MRECL               Yes, continue check max LRECL
         A     R15,WSRCODE               Else, accumulate RC
         ST    R15,WSRCODE
         OI    WSEFLAGS,WSEFERRP         Remember this error
         @MESSAGE ERROR,OPCODE=B,RC=(R15),                             +
               OPER=IO,TYPE=OPEN,OBJECT=WSSODSN,                       +
               EXIT=ERROR_EXIT
*
*  +-----------------------------------------------------------+
*  ¦   Check JES2FILE Record Length and Format                 ¦
*  ¦                                                           ¦
*  ¦   Max LRECL                                               ¦
*  ¦      o  If DCBLRECL > SSSOMLRL, use DCBLRECL              ¦
*  ¦      o  If DCBLRECL < SSSOMLRL,                           ¦
*  ¦           if not 0, use DCBLRECL                          ¦
*  ¦           else, use SSSOMLRL                              ¦
*  ¦                                                           ¦
*  ¦   RECFM                                                   ¦
*  ¦      o  Possibilities                                     ¦
*  ¦          ASA - FBA, VBA                                   ¦
*  ¦          MCC - FBM, VBM                                   ¦
*  +-----------------------------------------------------------+
*
CHECK_MRECL    EQU *
         LH    R2,DCBLRECL          Get lrecl
         LTR   R2,R2                Is it 0 ?
         BZ    CHECK_RECFM          Ignore if so
         CH    R2,=H'6200'          More than 6200 ?
         BNL   CHECK_RECFM          Ignore if so
         MVC   WSSOMLRL,DCBLRECL    Take it if a good number
         CH    R2,=H'121'           Less than 121  ?
         BNL   CHECK_RECFM          Ignore if not
         MVC   WSSOMLRL,=H'255'     Can not lower than 255 (safeguard)
CHECK_RECFM    EQU *
         @WTO  CODE=159
         TM    DCBRECFM,DCBRECCA    Is it ASA type sysout ?
         BO    ASA_FILE             Yes, handle it
         TM    DCBRECFM,DCBRECCM    Is it MCC type sysout ?
         BO    MCC_FILE             Yes, handle it
         TM    WSOFLAGS,WSOFTRAC
         BZ    WRONG_FORMAT
         @WTO  CODE=130
         B     WRONG_FORMAT
ASA_FILE EQU   *
         TM    WSOFLAGS,WSOFTRAC
         BZ    ASA_FILE1
         @WTO  CODE=131
ASA_FILE1 EQU  *
         MVI   WSCC,WSCC_ASA        Yes, set indicator
         B     ALLOC_FF             Continue
MCC_FILE EQU   *
         TM    WSOFLAGS,WSOFTRAC
         BZ    MCC_FILE1
         @WTO  CODE=132
MCC_FILE1 EQU  *
         MVI   WSCC,WSCC_MCC        Yes, set indicator
         B     ALLOC_FF             Continue
WRONG_FORMAT   EQU *
         @WTO  CODE=133
         OI    WSPFLAGS,WSPFOVER      Assume form has been overriden
         MVI   WSOVFORM,WSFFS390       using S/390 standard format ?
         @WTO  CODE=134
ALLOC_FF EQU *
         LH    R2,WSSOMLRL            Get LRECL from SSOB
         CH    R2,=H'6200'
         BH    ALLOC_FF_HI
         CH    R2,=H'133'
         BNL   ALLOC_FF_DO
ALLOC_FF_LO    EQU   *
         MVC   WSSOMLRL,=H'133'       Set max lrel is 149
         B     ALLOC_FF_DO
ALLOC_FF_HI    EQU   *
         TM    WSPFLAGS,WSPFFORC      Is it forced to use simple lrl ?
         BO    ALLOC_FF_FORCE         Yes, handle it
         @WTO  CODE=176,TRACE=ALWAYS
         OI    WSPFLAGS,WSPFOVER      Force override form
         MVI   WSOVFORM,WSFFS390       to S/390 standard format
         LH    R3,=H'32670'           Set max blksize (32670)
         LH    R2,=H'32666'           Set max lrecl = blksize - 4
         CH    R2,WSSOMLRL            Compare with its original
         BH    ALLOC_FF_EXEC          Agree if larger
         STH   R2,WSSOMLRL            Otherwise, force this value
         B     ALLOC_FF_EXEC          Then, proceed
ALLOC_FF_FORCE EQU   *
         OI    WSOFLAGS,WSOFFORC      Indicate it is in force mode
         LH    R3,=H'13030'           Set max blksize (13030)
         LH    R2,=H'250'             Set max lrecl = blksize - 4
         CH    R2,WSSOMLRL            Compare with its original
         BL    ALLOC_FF_EXEC          Agree if shorter
         LH    R2,WSSOMLRL            Otherwise, use JES info MLRL
         B     ALLOC_FF_EXEC          Then, proceed
*
*  +-----------------------------------------------------------+
*  ¦   Allocate LCLDS01                                        ¦
*  ¦      o  Type flat file                                    ¦
*  ¦      o  Output                                            ¦
*  ¦      o  Mapped by FRB & FRBP block in WTX                 ¦
*  ¦      o  Possibilities                                     ¦
*  ¦         -  Form Dispatch or Windows - VB                  ¦
*  ¦         -  Form standard S/390 - VBA or VBM               ¦
*  ¦      o  DDname 'LCLDS01'                                  ¦
*  ¦                                                           ¦
*  +-----------------------------------------------------------+
*
ALLOC_FF_DO    EQU *
         LH    R2,WSSOMLRL            Get modified LRECL from SSOB
         LA    R2,16(,R2)             Increase for RDW
         LH    R3,=H'6233'                Normal blocksize
ALLOC_FF_EXEC  EQU *
         L     R8,ADDR_LCLDS01        Access DCB of LCLDS01
         @DYNAMIC UPDATE,             Update flat file SVC 99 parm     +
               DSN=WSFFDSN,           Use edited DSN                   +
               DD='LCLDS01',          DD name is LCLDS01               +
               PREFIX=F,              The prefix is F                  +
               LRECL=(R2),            Set LRECL                        +
               BLKSIZE=(R3),          Set BLKSIZE                      +
               RECFM=VB,              Use VB format                    +
               ERRMSG=WTO,            Display error msg using WTO      +
               LOC=*                  Inline
         @MESSAGE INFO,OPCODE=B,OPER=SHOW,TYPE=SVC99DSN,               +
               OBJECT=FRBDSN,TEXT='from internal edition'
         MVC   WSBYTE,WSFFLAGS
         TM    WSPFLAGS,WSPFOVER      Is form overriden ?
         BZ    ALLOC_FF_STD           No, just take normal way
         CLI   WSOVFORM,WSFFS390      Is it S/390 standard format ?
         BE    ALLOC_FF_S390          Yes, process it
         B     ALLOC_FF_GO            No, passthru
ALLOC_FF_STD EQU *
         CLI   WSFFLAGS,WSFFS390      Is it S/390 standard format ?
         BE    ALLOC_FF_S390          Yes, process it
ALLOC_FF_GO    EQU *
         @DYNAMIC ALLOCATE,           Update flat file SVC 99 parm     +
               PREFIX=F,              The prefix is F                  +
               LOC=*                  Inline
ALLOC_RC EQU   *
         LTR   R15,R15
         BZ    OPEN_FF
         A     R15,WSRCODE            Accumulate RC
         ST    R15,WSRCODE
         OI    WSEFLAGS,WSEFERRP      Remember this error
         @MESSAGE ERROR,OPCODE=B,OPER=DYNALLOC,TYPE=ALLOC,             +
               OBJECT=WSFFDSN,RC=FRBERR,EXIT=ERROR_EXIT
         B     ERROR_EXIT
OPEN_FF  EQU   *
         @WTO  CODE=160
         OI    WSSFLAGS,WSSFAFFL      Remember LCLDS01 allocated
         L     R7,DCBDCBE
         MVC   DCBESYNA,=A(SPOOL_SYN) Prepare SYN exit routine
         OPEN  ((R8),(OUTPUT)),MODE=31,    Open DCB of LCLDS01         +
               MF=(E,LOPEN_LCLDS01)   !!! Remember - DATA MODE
         TM    DCBOFLGS,DCBOFOPN      Is it work ?
         BNZ   PROCESS_SPOOL
         A     R15,WSRCODE            Accumulate RC
         ST    R15,WSRCODE
         OI    WSEFLAGS,WSEFERRP      Remember this error
         @MESSAGE ERROR,OPCODE=B,RC=(R15),                             +
               OPER=IO,TYPE=OPEN,OBJECT=WSFFDSN,                       +
               EXIT=ERROR_EXIT
ALLOC_FF_S390 EQU *
         MVC   WSBYTE,WSOVFORM
         L     R8,ADDR_LCLDS02      Switch to use LCLDS02 (locate mode)
         ST    R8,ADDR_LCLDS01
         @DYNAMIC UPDATE,             Update flat file SVC 99 parm     +
               DD='LCLDS02',          DD name is LCLDS01               +
               PREFIX=F,              The prefix is F                  +
               LOC=*                  Inline
         CLI   WSCC,WSCC_ASA        Is it ASA formatted sysout ?
         BE    ALLOC_FF_S390_ASA    Ya, perform it
         CLI   WSCC,WSCC_MCC        Is it MCC formatted sysout ?
         BE    ALLOC_FF_S390_MCC    Yes, do it
         B     ALLOC_FF_GO          Otherwise, forget them both
ALLOC_FF_S390_ASA EQU *
         @DYNAMIC ALLOCATE,           Update flat file SVC 99 parm     +
               PREFIX=F,              The prefix is F                  +
               RECFM=VBA,             Indicate ASA bieng used          +
               LOC=*                  Inline
         B     ALLOC_RC
ALLOC_FF_S390_MCC EQU *
         @DYNAMIC ALLOCATE,           Update flat file SVC 99 parm     +
               PREFIX=F,              The prefix is F                  +
               RECFM=VBM,             Indicate MCC bieng used          +
               LOC=*                  Inline
         B     ALLOC_RC
         EJECT ,
*
*  +--------------------------------------------------------------+
*  |  Process spoolfile (sysout) & flatfile (dataset)             |
*  |  (1)  Initialize flat file w/ 3 records CADS-type header.    |
*  |  (2)  Sysout is to be read into memory, record by record.    |
*  |       Check CC in 1st byte of each record.                   |
*  |  (3)  Write each spoolfile-record into flatfile record w/o   |
*  |       CC with the following rule:                            |
*  |         If CC = page-break then insert 3rd CADS-type header  |
*  |         record into flatfile.                                |
*  +--------------------------------------------------------------+
*
         DS    0H
PROCESS_SPOOL  EQU *
         NI    WSEFLAGS,X'FF'-WSEFIOER   Assume no I/O error
         MVC   WSLRECL,DCBLRECL
         @XCOMJOB EXEC,                                                +
               PREFIX=XC,                                              +
               PCDRIVE=WSPCDRVE,                                       +
               EXTTYPE=WSBYTE,                                         +
               LOC=*
         L     R15,WSMODWTR         Access WTR module
         TM    WSOFLAGS,WSOFFORC    Is it forced to use simple lrl ?
         BZ    CALL_WRITER          No, just call writer
         L     R15,WSMODWTB         Yes, use WTB module intsead
CALL_WRITER    EQU *
         LR    R1,R10               Address of WSA
         BASR  R14,R15              Call WTR
         NI    WSOFLAGS,X'FF'-WSOFFORC Clear force indicator
         LTR   R15,R15              Check RC
         BZ    SPOOL_END            Just end if no error
         OI    WSEFLAGS,WSEFIOER    Remember the error
         A     R15,WSRCODE            Accumulate RC
         ST    R15,WSRCODE
         B     SPOOL_END
*
SPOOL_SYN EQU *
*        PR   ,                     Unstack status
         @WTO  CODE=148
SPOOL_END EQU  *
CLOSE_SO EQU   *
         @WTO  CODE=161
         L     R8,ADDR_JES2FILE     Access DCB of JES2FILE
         CLOSE ((R8)),MODE=31,MF=(E,LCLOSE_JES2FILE) Close sysout
         LTR   R15,R15
         BZ    FREE_SO
         A     R15,WSRCODE            Accumulate RC
         ST    R15,WSRCODE
         WTO   'DERXIO999E Close error for file JES2FILE'
FREE_SO  EQU   *
         @DYNAMIC FREE,               Prepare sysout SVC 99 parm       +
               ERRMSG=WTO,            Display error msg using WTO      +
               PREFIX=D,              The prefix is D                  +
               TOLFAIL=1080,          Tolerate 1080 error              +
               LOC=*                  Inline
         LTR   R15,R15
         BZ    FREE_SO_OKEY
         TM    WSSFLAGS,WSSFAJES      Is JES2FILE actually allocated
         BZ    CLOSE_FF               No, just skip
         A     R15,WSRCODE            Accumulate RC
         ST    R15,WSRCODE
         @WTO  CODE=163
         OI    WSEFLAGS,WSEFERRP      Remember this error
         @MESSAGE ERROR,OPCODE=B,OPER=DYNALLOC,TYPE=DEALLOC,           +
               OBJECT=WSSODSN,RC=DRBERR,EXIT=CLOSE_FF
         B     CLOSE_FF
FREE_SO_OKEY   EQU *
         NI    WSSFLAGS,X'FF'-WSSFAJES Turn indicator off
CLOSE_FF EQU   *
         @WTO  CODE=162
         L     R8,ADDR_LCLDS01        Access DCB of LCLDS01
         TM    DCBOFLGS,DCBOFOPN      Is it open ?
         BZ    FREE_FF                No, just leave it
         CLOSE ((R8),FREE),MODE=31,MF=(E,LCLOSE_LCLDS01) Close flatDS
         LTR   R15,R15
         BZ    FREE_FF
         A     R15,WSRCODE            Accumulate RC
         ST    R15,WSRCODE
         WTO   'DERXIO999E Close error for file LCLDS01'
FREE_FF  EQU   *
         @DYNAMIC FREE,               Prepare flatDS SVC 99 parm       +
               ERRMSG=WTO,            Display error msg using WTO      +
               PREFIX=U,              The prefix is U                  +
               TOLFAIL=1080,          Tolerate 1080 error              +
               LOC=*                  Inline
         LTR   R15,R15
         BZ    FREE_FF_OKEY           Just skip if RC 0
         TM    WSSFLAGS,WSSFAFFL      Is LCLDS01 actually allocated
         BZ    SUBMIT_XCOM            No, just skip
         A     R15,WSRCODE            Accumulate RC
         ST    R15,WSRCODE
         OI    WSEFLAGS,WSEFERRP      Remember this error
         @MESSAGE ERROR,OPCODE=B,OPER=DYNALLOC,TYPE=DEALLOC,           +
               OBJECT=WSFFDSN,RC=URBERR,EXIT=SUBMIT_XCOM
         B     SUBMIT_XCOM            Submit XCOM job
FREE_FF_OKEY   EQU *
         NI    WSSFLAGS,X'FF'-WSSFAFFL Turn indicator off
         B     SUBMIT_XCOM            Submit XCOM job
*
* XCOM INTERFACE
* -----------------------
*        TM    WSOFLAGS,WSOFXCOM   Is XCOM being called internally ?
*        BZ    SUBMIT_XCOM
*
SUBMIT_XCOM    EQU *
         TM    WSEFLAGS,WSEFIOER   Any I/O error
         BNZ   ERROR_EXIT          Yes, exit
         LA    R2,XCJCL            Point to XCOM JCL
         LA    R3,XCJCARDS-2       Number of cards - 2
         L     R5,ADDR_INTRDR      Address of INTRDR DCB
SEND_JCL EQU   *
         PUT   (R5),(R2)           Put a card into INTRDR
         CLC   =C'/*EOF',0(R2)     Is EOF sign reached ?
         BE    END_SUBMIT          Yes, finish submission
         LA    R2,80(,R2)          Bump to next card
         BCT   R3,SEND_JCL         Iterate
         MVC   0(8,R2),=CL8'/*EOF'   Make new EOF sign
         MVC   8(72,R2),7(R2)      Roll blank to clear the card
END_SUBMIT     EQU *
         MVC   XCGROUP(8),=CL8'GROUP='
         @WTO  CODE=164
         B     EXIT
         LTORG ,
         DS    0D
*
* +--------------------------------+
* | EXIT Procedure                 |
* | Due to everything done, then   |
* | return to DERXDI               |
* +--------------------------------+
*
ERROR_EXIT     EQU *
         @WTO  CODE=147
EXIT     EQU   *
         L     R8,ADDR_LCLDS01      Map LCLDS01 DCB
         TM    DCBOFLGS,DCBOFOPN    Is it open ?
         BZ    EXIT01               No, just leave it
         CLOSE ((R8),FREE),MODE=31,MF=(E,LCLOSE_LCLDS01) Close flatDS
         LTR   R15,R15
         BZ    EXIT01
         A     R15,WSRCODE            Add to saved RC
         ST    R15,WSRCODE
         WTO   'DERXIO999E Close error 2x for file LCLDS01'
EXIT01   EQU   *
         TM    WSSFLAGS,WSSFAFFL    Is LCLDS01 still allocated
         BZ    EXIT02               No, just skip
         @DYNAMIC FREE,               Prepare sysout SVC 99 parm       +
               PREFIX=U,              The prefix is D                  +
               TOLFAIL=1080,          Tolerate 1080 error              +
               LOC=*                  Inline
         LTR   R15,R15
         BZ    EXIT01A
         A     R15,WSRCODE            Add to saved RC
         ST    R15,WSRCODE
         WTO   'DERXIO999E Dealloc error 2x for file LCLDS01'
         B     EXIT02
EXIT01A  EQU   *
         NI    WSSFLAGS,X'FF'-WSSFAFFL  Turn indicator off
EXIT02   EQU   *
         L     R8,ADDR_JES2FILE     Map JES2FILE DCB
         TM    DCBOFLGS,DCBOFOPN    Is it open ?
         BZ    EXIT03               No, just leave it
         CLOSE ((R8),FREE),MODE=31,MF=(E,LCLOSE_JES2FILE) Close sysout
         LTR   R15,R15
         BZ    EXIT03
         A     R15,WSRCODE            Add to saved RC
         ST    R15,WSRCODE
         WTO   'DERXIO999E Close error 2x for file JES2FILE'
EXIT03   EQU   *
         TM    WSSFLAGS,WSSFAJES    Is JES2FILE still allocated
         BZ    EXIT04               No, just skip
         @DYNAMIC FREE,               Prepare sysout SVC 99 parm       +
               PREFIX=D,              The prefix is D                  +
               TOLFAIL=1080,          Tolerate 1080 error              +
               LOC=*                  Inline
         LTR   R15,R15
         BZ    EXIT03A
         A     R15,WSRCODE            Add to saved RC
         ST    R15,WSRCODE
         WTO   'DERXIO999E Dealloc error 2x for file JES2FILE'
         B     EXIT04
EXIT03A  EQU   *
         NI    WSSFLAGS,X'FF'-WSSFAJES  Turn indicator off
EXIT04   EQU   *
*        NI    WSPFLAGS,X'FF'-WSPFOVER  Turn override bit off
         TM    WSEFLAGS,WSEFERRP    Any serious error ?
         BZ    EXIT05               No, just exit
         LA    R15,8                Make RC = 8
         A     R15,WSRCODE            Add to saved RC
         ST    R15,WSRCODE
EXIT05   EQU   *
         MVC   ADDR_LCLDS01,ADDR_IEFRDER  Restore LCLDS01 DCB pointer
         B     EXIT06
         LA    R2,WSASIZE(,R1)
         PGSER R,FREE,A=(R1),EA=(R2),ECB=0,RELEASE=N
         LM    R1,R2,WSMODWTX
         LA    R2,0(R1,R2)
         PGSER R,FREE,A=(R1),EA=(R2),ECB=0,RELEASE=N
         LM    R1,R2,WSMODDCB
         LA    R2,0(R1,R2)
         PGSER R,FREE,A=(R1),EA=(R2),ECB=0,RELEASE=N
EXIT06   EQU   *
         L     R15,WSRCODE          Set RC
         @EXIT
         LTORG ,
         EJECT
*
* +--------------------------------+
* | Working Storage Area Map       |
* | Used as working set and other  |
* | dynamic storages directory     |
* +--------------------------------+
*
         DERWSA
         EJECT ,
*
* +--------------------------------+
* | Module Extension Area Map      |
* | Used as a non reentrant part   |
* | of this module                 |
* +--------------------------------+
*
         DERWTX TYPE=DSECT
*
*   STANDARD MVS SOURCE COPY
*   FOR DSECTS AND EQUATES
*   ------------------------
*
         PRINT NOGEN
         DERTABCC
         CVT   DSECT=YES
         DCBD  DSORG=(PO,PS)
         IHADCBE
         IEFJESCT TYPE=DSECT,MNTBL=YES
         IEFJSSOB (SO,AG,AL),CONTIG=YES
         IEFZB4D0
*        IEFZB4D2
         END   DERXIO
./ ADD NAME=DERXSF   0100-01324-01324-1743-00214-00214-00000-DERU-S
**********************************************************************
*
*                     +---------+
*     Module Name  -  | DERXSF  |
*                     +---------+
*                     Local External Writer Component to Support
*                     CA-Dispatch and CA-XCOM Handshaking
*
*     Function -
*            Output writer routine to copy sysout into flat dataset
*            files and submit XCOMJOB.
*
*     Operating Environment -
*        Type              MVS System Program
*        Min. Auth.        Supervisor state
*        Dsp.unit mode     Task
*        AMODE             24-bit or 31-bit
*        XM                PASN=HASN=SASN
*        ASC mode          Primary
*        Interrupt status  Enabled for I/O and Ext. interrupts
*        Locks             No locks held
*        Control Parm      The SSOB and SSSO control blocks can
*                          reside in storage above 16 megabytes.
*        Recovery          Program should provide an ESTAE-type
*                          recovery environment. See MVS/ESA SP V5
*                          Auth Assembler Services Guide for more info
*                          an ESTAE-type recovery environment.
*
*
*     Syntax -
*          None
*
*     Operation -
*
*
*     Register Usage -
*          R0-R1   -->  System interface
*          R2-R7   -->  Work registers
*          R8      -->  DCB map (IHADCB) address
*          R9      -->  Module extension base address
*          R10     -->  WSA (working storage area) address
*          R11     -->  SSSO block address
*          R12     -->  Main module base address
*          R13     -->  Conventional savearea
*          R14     -->  BAS or BASR return address
*          R15     -->  Return code
*
*     Author -
*          Name     :  Deru Sudibyo
*                      Technical Consultant
*                      Computer Associates
*                      Indonesia Office
*                      Wisma BNI-46 34th floor, BNI-46 City
*                      Jl. Jend. Sudirman, Kav 1, Jakarta Pusat
*          Copyright:  (C)1998 Deru Sudibyo
*
*     Disclaimer -
*         This module is developed as a personal support, and is
*         not a part of CA support matterials.  The purpose is as
*         a temporary solution or even just a sample.  Therefor,
*         further modifications and maintenance are client's
*         responsibilities.
*
*     Modification Log -
*     +--------+------------+--------+---------------------------+
*     | Date   | Engineer   | V.R.L. | Description               |
*     +--------+------------+--------+---------------------------+
*     |98/02/12| Deru S.    | 1.0.0. | First development         |
*     |        |            |        |                           |
*     |        |            |        |                           |
*     |        |            |        |                           |
*     |        |            |        |                           |
*     |        |            |        |                           |
*     |        |            |        |                           |
*     +--------+------------+--------+---------------------------+
*
*
         EJECT ,
DERXSF   @PROLOG ESA=390,                                              +
               AMODE=31,                                               +
               RMODE=24,                                               +
               RENT=YES,                                               +
               BREG=R12
*
         USING DCBE,R7            Establish DCBE structure map
         USING IHADCB,R8          Establish DCB structure map
         USING DERWTX,R9          Establish Module extension logic map
         USING WSA,R10            Establish WSA structure map
         USING SSOB,R11           Establish SSOB structure map
*
*        LR    R10,R1             Enable WSA addressability
         LOAD  EP=DERWSA
         LR    R10,R0             Enable WSA addressability
         L     R11,WSSSOB         Enable WSA addressability
         L     R9,WSMODWTX        Enable WTX addressability
         EJECT ,
*********************************************************************
*
*   ALLOCATE SYSOUT and FLATFILE Datasets
*   -------------------------------------
*
*   (1)  Allocate sysout dataset as SYSOUT with DSN copied from
*        SSOB and request is passed to subsystem named JES2.
*
*   (2)  Create XCOMJOB JCL which includes
*          - Obtain system date and time
*          - Construct flatfile DSN that describe Recipient-id
*            (DESTid copied from SSOB), current system date and time,
*            and Report-id (WTR-name from SSOB)
*
*   (3)  Allocate flatfile dataset as LCLDS01 with DSN copied
*        from (2), Lrecl copied from SSOB, Blkzise 6233 and all
*        other space parameters just estimated.
*
*   (4)  Check whether remote destination from is DISPATCH.  If so,
*        prepare all DISPATCH page headers.
*
*   (5)  Return.
*
         DS    0H
ALLOC    EQU *
         @EDITTOD
         CP    WSCOUNT,=P'999999'     Has maximum count reached ?
         BL    GOHEAD                 No, go ahead
         ZAP   WSCOUNT,=PL1'0'        Yes, reset counter
GOHEAD   AP    WSCOUNT,=PL1'1'        Increment counter
         OI    WSCOUNT+L'WSCOUNT-1,X'0F'
         UNPK  WSJNUM,WSCOUNT         Mark jobname of XCnnnnnn
         @XCOMJOB EXEC,                                                +
               PREFIX=XC,                                              +
               LOC=*,DSN=WSSODSN,                                      +
               RPTNAME=WSSOWRTR,        From SSSOPGMN                  +
               RCPID=WSSODEST,          From SSSODEST                  +
               DISP='(OLD,KEEP)',                                      +
               JOBNUM=WSJNUM
CONT     EQU   *
         AP    WSCOUNT,=PL1'1'      Increment counter
         ZAP   WSPGNUM,=PL1'0'      Initialize page number
*
* XCOM INTERFACE
* -----------------------
*        TM    WSOFLAGS,WSOFXCOM   Is XCOM being called internally ?
*        BZ    SUBMIT_XCOM
*
SUBMIT_XCOM    EQU *
         LA    R2,XCJCL            Point to XCOM JCL
         LA    R3,XCJCARDS         Number of cards
         L     R5,ADDR_INTRDR      Address of INTRDR DCB
         TM    WSOFLAGS,WSOFTRAC   Is trace on ?
         BO    SUBMIT_TRACE        No, just go
SEND_JCL EQU   *
         PUT   (R5),(R2)           Put a card into INTRDR
         CLC   =C'/*EOF',0(R2)     Is EOF sign reached ?
         BE    END_SUBMIT          Yes, finish submission
         LA    R2,80(,R2)          Bump to next card
         BCT   R3,SEND_JCL         Iterate
         B     END_SUBMIT
SUBMIT_TRACE   EQU *
         MVC   WSWORK(2),=AL2(72)
         MVC   WSWORK+2(12),=C'XDI Trace ='
SEND_JCL_TRACE EQU *
         PUT   (R5),(R2)           Put a card into INTRDR
         MVC   WSWORK+14(60),0(R2)
         WTO   TEXT=WSWORK,MF=(E,LWTO)
         CLC   =C'/*EOF',0(R2)     Is EOF sign reached ?
         BE    END_SUBMIT          Yes, finish submission
         LA    R2,80(,R2)          Bump to next card
         BCT   R3,SEND_JCL_TRACE   Iterate
END_SUBMIT     EQU *
         MVC   XCGROUP(8),=CL8'GROUP='
*
* +--------------------------------+
* | EXIT Procedure                 |
* | Due to everything done, then   |
* | return to DERXDI               |
* +--------------------------------+
*
EXIT     EQU   *
         XR    R15,R15             Set RC = 0
         @EXIT
         LTORG ,
         EJECT
*
* +--------------------------------+
* | Working Storage Area Map       |
* | Used as working set and other  |
* | dynamic storages directory     |
* +--------------------------------+
*
         DERWSA
         EJECT ,
*
* +--------------------------------+
* | Module Extension Area Map      |
* | Used as a non reentrant part   |
* | of this module                 |
* +--------------------------------+
*
         DERWTX TYPE=DSECT
*
*   STANDARD MVS SOURCE COPY
*   FOR DSECTS AND EQUATES
*   ------------------------
*
         PRINT NOGEN
         DERTABCC
         CVT   DSECT=YES
         DCBD  DSORG=(PO,PS)
         IHADCBE
         IEFJESCT TYPE=DSECT,MNTBL=YES
         IEFJSSOB (SO,AG,AL),CONTIG=YES
         IEFZB4D0
*        IEFZB4D2
         END   DERXSF
./ ADD NAME=DERXWR   0100-01324-01324-1743-00525-00525-00000-DERU-S
**********************************************************************
*
*                     +---------+
*     Module Name  -  | DERXWR  |
*                     +---------+
*                     Local External Writer Component to Support
*                     CA-Dispatch and CA-XCOM Handshaking
*
*     Function -
*            Output writer routine to copy sysout into flat dataset
*            files and submit XCOMJOB.
*
*     Operating Environment -
*        Type              MVS System Program
*        Min. Auth.        Supervisor state
*        Dsp.unit mode     Task
*        AMODE             24-bit or 31-bit
*        XM                PASN=HASN=SASN
*        ASC mode          Primary
*        Interrupt status  Enabled for I/O and Ext. interrupts
*        Locks             No locks held
*        Control Parm      The SSOB and SSSO control blocks can
*                          reside in storage above 16 megabytes.
*        Recovery          Program should provide an ESTAE-type
*                          recovery environment. See MVS/ESA SP V5
*                          Auth Assembler Services Guide for more info
*                          an ESTAE-type recovery environment.
*
*
*     Syntax -
*          None
*
*     Operation -
*
*
*     Register Usage -
*          R0-R1   -->  System interface
*          R2-R6   -->  Work registers
*          R7      -->  DCB map (IHADCB) address of SYSOUT
*          R8      -->  DCB map (IHADCB) address of LCLDS01
*          R9      -->  Module extension base address
*          R10     -->  WSA (working storage area) address
*          R11     -->  Flat File record map
*          R12     -->  Main module base address
*          R13     -->  Conventional savearea
*          R14     -->  BAS or BASR return address
*          R15     -->  Return code
*
*     Author -
*          Name     :  Deru Sudibyo
*                      Technical Consultant
*                      Computer Associates
*                      Indonesia Office
*                      Wisma BNI-46 34th floor, BNI-46 City
*                      Jl. Jend. Sudirman, Kav 1, Jakarta Pusat
*          Copyright:  (C)1998 Deru Sudibyo
*
*     Disclaimer -
*         This module is developed as a personal support, and is
*         not a part of CA support matterials.  The purpose is as
*         a temporary solution or even just a sample.  Therefor,
*         further modifications and maintenance are client's
*         responsibilities.
*
*     Modification Log -
*     +--------+------------+--------+---------------------------+
*     | Date   | Engineer   | V.R.L. | Description               |
*     +--------+------------+--------+---------------------------+
*     |98/02/12| Deru S.    | 1.0.0. | First development         |
*     |        |            |        |                           |
*     |        |            |        |                           |
*     |        |            |        |                           |
*     |        |            |        |                           |
*     |        |            |        |                           |
*     |        |            |        |                           |
*     +--------+------------+--------+---------------------------+
*
*
         EJECT ,
DERXWR   @PROLOG ESA=390,                                              +
               AMODE=31,                                               +
               RMODE=24,                                               +
               RENT=YES,                                               +
               BREG=R12
*
         USING DCBE,R7            Establish DCBE structure map
         USING IHADCB,R8          Establish DCB structure map
         USING DERWTX,R9          Establish Module extension logic map
         USING WSA,R10            Establish WSA structure map
         USING FFRECMAP,R11       Establish Flat file record map
*
*        LR    R10,R1             Enable WSA map
*        L     R9,WSMODWTX        Enable WTX map
*
         LOAD  EP=DERWSA
         LR    R10,R0             Enable WSA addressability
         LOAD  EP=DERWTX
         LR    R9,R0              Enable WTX addressability
         LOAD  EP=DERDCB
         L     R8,ADDR_JES2FILE     Access DCB of JES2FILE
         L     R7,DCBDCBE
         CLC   =C'DCBE',0(R7)
         BE    INSTALL_EODA
         WTO   'DER999999E DCBE Lost before I/O process begun...!!!'
         B     EXIT
INSTALL_EODA   EQU *
         MVC   DCBEODA,=AL3(SPOOL_END)
         MVC   DCBSYNA,=AL3(SPOOL_SYN)
         MVC   DCBEEODA,=A(SPOOL_END)
         MVC   DCBESYNA,=A(SPOOL_SYN)
         L     R8,ADDR_LCLDS01      Access DCB of LCLDS01
         L     R7,DCBDCBE
         MVC   DCBSYNA,=AL3(SPOOL_SYN)
         MVC   DCBESYNA,=A(SPOOL_SYN)
         L     R11,WSIOBUF          Record buffer
         XC    FFRRDW,FFRRDW
         EJECT ,
*
*  +--------------------------------------------------------------+
*  |  Process spoolfile (sysout) & flatfile (dataset)             |
*  |  (1)  Initialize flat file w/ 3 records CADS-type header.    |
*  |  (2)  Sysout is to be read into memory, record by record.    |
*  |       Check CC in 1st byte of each record.                   |
*  |  (3)  Write each spoolfile-record into flatfile record w/o   |
*  |       CC with the following rule:                            |
*  |         If CC = page-break then insert 3rd CADS-type header  |
*  |         record into flatfile.                                |
*  +--------------------------------------------------------------+
*
         DS    0H
PROCESS_SPOOL  EQU *
         @WTO  CODE=177
         L     $SYSOUT,ADDR_JES2FILE Access DCB of JES2FILE
         L     $FLATDS,ADDR_LCLDS01 Access DCB of LCLDS01
         TM    WSPFLAGS,WSPFOVER    Is form overriden ?
         BZ    PROCESS_STD          No, just take normal way
         CLI   WSOVFORM,WSFFS390    Is it S/390 standard format ?
         BE    PROCESS_S390         Yes, process it
         CLI   WSCC,WSCC_ASA        Is it ASA formatted sysout ?
         BNE   PROCESS_MCC          No, it should MCC format, handle it
         CLI   WSOVFORM,WSFFDISP    Is it Dispatch format ?
         BE    ASA_DISPATCH         Yes, process it
         CLI   WSOVFORM,WSFFWIND    Is it Windows format ?
         BE    ASA_WINDOWS          Yes, process it
         B     PROCESS_S390         Otherwise, assume standard
PROCESS_STD    EQU *
         CLI   WSFFLAGS,WSFFS390    Is it S/390 format ?
         BE    PROCESS_S390         Yes, process it
         CLI   WSCC,WSCC_ASA        Is it ASA formatted sysout ?
         BNE   PROCESS_MCC          No, it should MCC format, handle it
         CLI   WSFFLAGS,WSFFDISP    Is it Dispatch format ?
         BE    ASA_DISPATCH         Yes, process it
         CLI   WSFFLAGS,WSFFWIND    Is it Windows format ?
         BE    ASA_WINDOWS          Yes, process it
         B     PROCESS_S390         Otherwise, assume standard
*
ASA_DISPATCH   EQU *
         @WTO  CODE=178
         BAS   R6,DSP_HEADER       Build header
ASA_DSP_READ   EQU *
         GET   ($SYSOUT)  JES2FILE  Load sysout record
         BAS   R14,CALC_I_LRECL     Calculate lrecl & setup RDW
         LA    R5,ASA_DSP_NEWPAGE   Return address if true
         BAS   R6,ASA_TEST_CHANNEL
         BAS   R6,ASA_TEST         Check all others
         B     ASA_DSP_READ         Interate
ASA_DSP_NEWPAGE EQU *
         BAS   R6,DSP_PAGE_HEADER Write page header
         BAS   R6,ASA_SPACE1       Write 1st line record
         B     ASA_DSP_READ         Interate
ASA_WINDOWS    EQU *
         @WTO  CODE=179
ASA_WIN_READ   EQU *
         GET   ($SYSOUT) JES2FILE   Load sysout record
         BAS   R14,CALC_I_LRECL     Calculate lrecl & setup RDW
         LA    R5,ASA_WIN_NEWPAGE
         BAS   R6,ASA_TEST_CHANNEL
         BAS   R6,ASA_TEST         Check all others
         B     ASA_WIN_READ         Interate
ASA_WIN_NEWPAGE EQU *
         MVI   FFRDATA,X'0C'        Put page-break sign
         BAS   R14,CALC_O_LRECL     Calculate output LRECL
         EX    R2,ASA_WIN_REC1
         PUT   ($FLATDS),FFREC LCLDS01 Store into flatfile
         B     ASA_WIN_READ         Interate
ASA_WIN_REC1   MVC FFRDATA+1(*-*),0(R3) Move data from sysout buffer
ASA_TEST EQU   *
         CLI   0(R1),$ASA_SP1       Is it space 1 line ?
         BE    ASA_SPACE1           Yes, handle it
         CLI   0(R1),$ASA_SP2       Is it space 2 line ?
         BE    ASA_SPACE2           Yes, handle it
         CLI   0(R1),$ASA_SP3       Is it space 3 line ?
         BE    ASA_SPACE3           Yes, handle it
*        CLI   0(R1),$ASA_SP0       Is it suppress line ?
*        BER   R6                   Yes, ignore it
         BR    R6                   Interate
ASA_SPACE1     EQU *
         BAS   R14,CALC_O_LRECL     Calculate output LRECL
         EX    R2,MOVE_FFREC
         PUT   ($FLATDS),FFREC LCLDS01 Store into flatfile
         BR    R6                   Interate
MOVE_FFREC     MVC FFRDATA(*-*),0(R3) Move data from sysout buffer
ASA_SPACE2     EQU *
         LA    R4,1                 Do 1 x iteration
ASA_SPACE_LOOP EQU *
         MVC   FFRECLEN,=H'5'       This line is 1 byte space
         MVC   FFRDATA(8),=CL5' '
         PUT   ($FLATDS),FFREC LCLDS01 Store it into output file
         BCT   R4,ASA_SPACE_LOOP    Iterate
         B     ASA_SPACE1           Attempt to store record
ASA_SPACE3     EQU *
         LA    R4,2                 Do 2 x iteration
         B     ASA_SPACE_LOOP       Iterate
         SPACE ,
*
ASA_TEST_CHANNEL EQU *
         CLI   0(R1),$ASA_C01       Is it channel 1 skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$ASA_C02       Is it channel 2 skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$ASA_C03       Is it channel 3 skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$ASA_C04       Is it channel 4 skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$ASA_C05       Is it channel 5 skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$ASA_C06       Is it channel 6 skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$ASA_C07       Is it channel 7 skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$ASA_C08       Is it channel 8 skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$ASA_C09       Is it channel 9 skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$ASA_C10       Is it channel 10 skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$ASA_C11       Is it channel 11 skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$ASA_C12       Is it channel 12 skip ?
         BER   R5                   Yes, return
         BR    R6                   No, return to other gate
*
PROCESS_MCC    EQU *
         CLI   WSFFLAGS,WSFFDISP    Is it Dispatch format ?
         BNE   MCC_WINDOWS          No, it should Windows format
         @WTO  CODE=180
         BAS   R6,DSP_HEADER       Build header
MCC_DSP_EJECT  EQU *
         BAS   R6,DSP_PAGE_HEADER
MCC_DSP_READ   EQU *
         GET   ($SYSOUT) JES2FILE   Load sysout record
         BAS   R14,CALC_I_LRECL     Calculate lrecl & setup RDW
         LA    R5,MCC_DSP_EJECT     Address to handle EJECTion
         BAS   R6,MCC_TEST_EJECT   Evaluate MCC
         LA    R5,MCC_DSP_EJECT     Address to handle EJECTion
         BAS   R6,MCC_TEST_CHANNEL Address to handle channel skipping
         BAS   R6,MCC_LINE         Handle other MCC
         B     MCC_DSP_READ         Interate
MCC_WINDOWS    EQU *
         @WTO  CODE=181
MCC_WIN_READ   EQU *
         GET   ($SYSOUT) JES2FILE   Load sysout record
         BAS   R14,CALC_I_LRECL     Calculate lrecl & setup RDW
         LA    R5,MCC_WIN_EJECT     Address to handle EJECTion
         BAS   R6,MCC_TEST_EJECT   Evaluate MCC for EJECTion
         LA    R5,MCC_WIN_EJECT     Address to handle EJECTion
         BAS   R6,MCC_LINE         Process other MCC
         B     MCC_WIN_READ         Interate
MCC_WIN_EJECT  EQU *
         MVI   FFRDATA,X'0C'        Put page-break sign
         BAS   R14,CALC_O_LRECL     Calculate output LRECL
         GET   ($SYSOUT) JES2FILE   Load sysout record
         BAS   R14,CALC_I_LRECL     Calculate lrecl & setup RDW
         EX    R2,MCC_WIN_MVC
         PUT   ($FLATDS),FFREC LCLDS01 Store into flatfile
         B     MCC_WIN_READ         Interate
MCC_WIN_MVC    MVC FFRDATA+1(*-*),1(R1) Move data from sysout buffer
*
DSP_HEADER   EQU *
         XC    FFRRDW,FFRRDW
         L     $FLATDS,ADDR_LCLDS01   Access DCB of LCLDS01
         MVC   FFRDATA(L'PH1),PH1
         LA    R2,L'PH1             Length of header 1
         STH   R2,FFRECLEN          Lrecl > DCB lrecl  ?
         PUT   ($FLATDS),FFREC LCLDS01 Store into flatfile
         MVC   FFRDATA(L'PH2),PH2
         LA    R2,L'PH2             Length of header 1
         STH   R2,FFRECLEN          Lrecl > DCB lrecl  ?
         PUT   ($FLATDS),FFREC LCLDS01 Store into flatfile
         BR    R6                   Return
DSP_PAGE_HEADER EQU *
         AP    WSPGNUM,=PL1'1'      Increment page number
         @EDITHDR UPDATE,LOC=*,     Edit page number                   +
               PAGENUM=(DEC,WSPGNUM),                                  +
               PREFIX=PH
         LA    R2,L'PH3             Length of header 3
         STH   R2,FFRECLEN          Put it on DCB
         MVC   FFRDATA(L'PH3),PH3   Lrecl > DCB lrecl  ?
         PUT   ($FLATDS),FFREC LCLDS01 Store into flatfile
         BR    R6                   Return
*  Notes:
*   The following MCC will affect to take action
*   after printing.
MCC_LINE EQU   *
         CLI   0(R1),$MCC_SP1       Is it space 1 line ?
         BE    MCC_SPACE1           Yes, handle it
         CLI   0(R1),$MCC_SP2       Is it space 2 line ?
         BE    MCC_SPACE2           Yes, handle it
         CLI   0(R1),$MCC_SP3       Is it space 3 line ?
         BE    MCC_SPACE3           Yes, handle it
         CLI   0(R1),$MCC_SP0       Is it print only line ?
         BNER  R6                   No, ignore it, return
MCC_SPACE0     EQU *
         LA    R4,1                 Do not iterate
         B     MCC_PRINT
MCC_SPACE1     EQU *
         LA    R4,1                 Do 1 x iteration
         B     MCC_PRINT
MCC_SPACE2     EQU *
         LA    R4,2                 Do 2 x iteration
         B     MCC_PRINT
MCC_SPACE3     EQU *
         LA    R4,3                 Do 3 x iteration
MCC_PRINT EQU  *
         BAS   R14,CALC_O_LRECL     Calculate output LRECL
         EX    R2,MOVE_FFREC
         PUT   ($FLATDS),FFREC LCLDS01 Store sysout record into flatds
MCC_PRINT_SPACE EQU *
         BCT   R4,MCC_SPACE_LOOP
         BR    R6                   Interate
MCC_SPACE_LOOP EQU *
         MVC   FFRECLEN,=H'5'
         MVC   FFRDATA(8),=CL5' '   This line is 1 byte space
         PUT   ($FLATDS),FFREC LCLDS01 Store it into output file
         B     MCC_PRINT_SPACE      Iterate
         SPACE ,
*
MCC_TEST_CHANNEL EQU *
         CLI   0(R1),$MCC_C01       Is it channel 1 skip ?
         BE    MCC_PRINT_CHANNEL
         CLI   0(R1),$MCC_C02       Is it channel 2 skip ?
         BE    MCC_PRINT_CHANNEL
         CLI   0(R1),$MCC_C03       Is it channel 3 skip ?
         BE    MCC_PRINT_CHANNEL
         CLI   0(R1),$MCC_C04       Is it channel 4 skip ?
         BE    MCC_PRINT_CHANNEL
         CLI   0(R1),$MCC_C05       Is it channel 5 skip ?
         BE    MCC_PRINT_CHANNEL
         CLI   0(R1),$MCC_C06       Is it channel 6 skip ?
         BE    MCC_PRINT_CHANNEL
         CLI   0(R1),$MCC_C07       Is it channel 7 skip ?
         BE    MCC_PRINT_CHANNEL
         CLI   0(R1),$MCC_C08       Is it channel 8 skip ?
         BE    MCC_PRINT_CHANNEL
         CLI   0(R1),$MCC_C09       Is it channel 9 skip ?
         BE    MCC_PRINT_CHANNEL
         CLI   0(R1),$MCC_C10       Is it channel 10 skip ?
         BE    MCC_PRINT_CHANNEL
         CLI   0(R1),$MCC_C11       Is it channel 11 skip ?
         BE    MCC_PRINT_CHANNEL
         CLI   0(R1),$MCC_C12       Is it channel 12 skip ?
         BE    MCC_PRINT_CHANNEL
         BR    R6                   No, return to other gate
MCC_PRINT_CHANNEL EQU *
         LR    R6,R5                 Copy return address
         BAS   R14,CALC_O_LRECL     Calculate output LRECL
         EX    R2,MOVE_FFREC
         PUT   ($FLATDS),FFREC LCLDS01 Store sysout record into flatds
         BR    R6                   Return
*
MCC_TEST_EJECT EQU *
         CLI   0(R1),$MCC_C01I      Is it channel 1 immediate skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$MCC_C02I      Is it channel 2 immediate skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$MCC_C03I      Is it channel 3 immediate skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$MCC_C04I      Is it channel 4 immediate skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$MCC_C05I      Is it channel 5 immediate skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$MCC_C06I      Is it channel 6 immediate skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$MCC_C07I      Is it channel 7 immediate skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$MCC_C08I      Is it channel 8 immediate skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$MCC_C09I      Is it channel 9 immediate skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$MCC_C10I      Is it channel 10 immediate skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$MCC_C11I      Is it channel 11 immediate skip ?
         BER   R5                   Yes, return
         CLI   0(R1),$MCC_C12I      Is it channel 12 immediate skip ?
         BER   R5                   Yes, return
         BR    R6                   No, return to other gate
*
*  +-------------------------------------------------+
*  ¦                                                 ¦
*  ¦  Calculate LRECL of Input Dataset               ¦
*  ¦       - Called after GET                        ¦
*  ¦                                                 ¦
*  +-------------------------------------------------+
*
CALC_I_LRECL   EQU *
         XR    R2,R2
         ICM   R2,B'0111',0(R1)     Lrecl
         CH    R2,WSLRECL           Is it overlength
         BNH   LRECL_I_OKEY         No, good
         LH    R2,WSLRECL           Else, use max
LRECL_I_OKEY   EQU *
         LA    R2,1(R2)             Add 1
         STH   R2,FFRECLEN          Save it in RDW
         L     R1,WSRCAREA          Address of record
         LA    R3,1(R3)             Skip CC
         BR    R14
*
*  +-------------------------------------------------+
*  ¦                                                 ¦
*  ¦  Calculate LRECL of Output Dataset              ¦
*  ¦      - Called before PUT                        ¦
*  ¦                                                 ¦
*  +-------------------------------------------------+
*
CALC_O_LRECL   EQU *
         LH    R2,FFRECLEN          Get lrecl
         SH    R2,=H'5'             Reduce 5 (4 to skip RDW)
         LTR   R2,R2                Check
         BPR   R14                  If positif - good, return
         LA    R2,5                 Else, set minimum 5
         BR    R14                  Return
*
*  +-------------------------------------------------+
*  ¦                                                 ¦
*  ¦  Process S/390 Standard Format Dataset          ¦
*  ¦                                                 ¦
*  +-------------------------------------------------+
*
PROCESS_S390   EQU *
         @WTO  CODE=182
         L     R8,ADDR_JES2FILE     Access DCB of JES2FILE
         GET   (R8)    JES2FILE     Load sysout record
         LM    R4,R5,WSRCAREA       Record addr & length
         LR    R6,R1                Keep RDW
         L     R8,ADDR_LCLDS01      Access DCB of LCLDS02
         PUT   (R8)         LCLDS02  Store sysout record into flatfile
         LR    R2,R1
S390_LOOP EQU  *
         XR    R3,R3
         ICM   R3,B'0111',0(R1)     Get lrecl
         SH    R3,=H'5'
         CR    R3,R5
         BNH   S390_INPUT_LO
         LR    R3,R5
         B     S390_CHECK_MIN
S390_INPUT_LO  EQU *
         LR    R5,R3
S390_CHECK_MIN EQU *
         XC    0(4,R2),0(R2)        Zap RDW
         CH    R3,=H'5'             At least 5 byte, is it ?
         BH    S390_IN_TO_OUT       Yes, gohead
         LH    R3,=H'5'             No, make it 5
S390_IN_TO_OUT EQU *
         STH   R3,0(R2)             Set reclength
         LA    R2,4(,R2)            Jump over RDW
S390_MOVE_LOOP EQU *
         MVCL  R2,R4                Move input buf to output buf
         BC    1,S390_MOVE_LOOP     Loop if interrupted
         L     R8,ADDR_LCLDS01      Access DCB of LCLDS01
         PUT   (R8)         LCLDS02  Store sysout record into flatfile
         LR    R2,R1
         L     R8,ADDR_JES2FILE     Access DCB of JES2FILE
         GET   (R8)    JES2FILE     Load sysout record
         LM    R4,R5,WSRCAREA       Record addr & length
         LR    R6,R1                Keep RDW
         B     S390_LOOP
*
SPOOL_SYN EQU *
         @WTO  CODE=148
SPOOL_END EQU *
         @WTO  CODE=183
EXIT     EQU   *
         @EXIT
         LTORG ,
         EJECT
*
* +--------------------------------+
* | Working Storage Area Map       |
* | Used as working set and other  |
* | dynamic storages directory     |
* +--------------------------------+
*
         DERWSA
         EJECT ,
*
* +--------------------------------+
* | Module Extension Area Map      |
* | Used as a non reentrant part   |
* | of this module                 |
* +--------------------------------+
*
         DERWTX TYPE=DSECT
*
* +--------------------------------+
* | Flat File Record Area Map      |
* +--------------------------------+
*
FFRECMAP DERFFREC TYPE=DSECT
*
*   STANDARD MVS SOURCE COPY
*   FOR DSECTS AND EQUATES
*   ------------------------
*
         PRINT NOGEN
         DERTABCC
         CVT   DSECT=YES
         DCBD  DSORG=(PO,PS)
         IHADCBE
         IEFJESCT TYPE=DSECT,MNTBL=YES
         IEFJSSOB (SO,AG,AL),CONTIG=YES
         IEFZB4D0
*        IEFZB4D2
$FLATDS  EQU   7
$SYSOUT  EQU   8
         END   DERXWR
